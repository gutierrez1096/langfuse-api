This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
docs/
  openapi.yaml
src/
  config/
    database.js
    index.js
  controllers/
    api-keys.controller.js
    health.controller.js
    organizations.controller.js
    project-memberships.controller.js
    projects.controller.js
    users.controller.js
  middleware/
    auth.middleware.js
    error.middleware.js
    request.middleware.js
    validation.middleware.js
  routes/
    api-keys.routes.js
    health.routes.js
    index.js
    organizations.routes.js
    project-memberships.routes.js
    projects.routes.js
    users.routes.js
  services/
    api-keys.service.js
    database.service.js
    organizations.service.js
    project-memberships.service.js
    projects.service.js
    users.service.js
  utils/
    config-checker.js
    errors.js
    id-generator.js
    logger.js
  app.js
.dockerignore
.eslintrc.js
.gitignore
Dockerfile
index.js
package.json
README.md

================================================================
Files
================================================================

================
File: docs/openapi.yaml
================
openapi: 3.0.3
info:
  title: Langfuse Admin API
  description: |
    API de administración para Langfuse que permite gestionar organizaciones, proyectos, usuarios y API keys.
    Esta API está diseñada para uso administrativo con autenticación mediante API key.
  version: 1.0.0
  contact:
    name: Langfuse Team
    url: https://langfuse.com
servers:
  - url: http://localhost:3100/api
    description: Servidor local de desarrollo
  - url: https://admin-api.langfuse.com/api
    description: Servidor de producción

components:
  securitySchemes:
    ApiKeyAuth:
      type: apiKey
      in: header
      name: X-API-Key
  
  schemas:
    Error:
      type: object
      properties:
        error:
          type: string
          description: Código de error
        message:
          type: string
          description: Mensaje de error
        details:
          type: object
          description: Detalles adicionales del error (opcional)
    
    Organization:
      type: object
      properties:
        id:
          type: string
          description: ID único de la organización
        name:
          type: string
          description: Nombre de la organización
        created_at:
          type: string
          format: date-time
          description: Fecha de creación
        updated_at:
          type: string
          format: date-time
          description: Fecha de última actualización
    
    OrganizationMember:
      type: object
      properties:
        id:
          type: string
          description: ID único de la membresía
        user_id:
          type: string
          description: ID del usuario
        role:
          type: string
          enum: [OWNER, ADMIN, VIEWER, NONE]
          description: Rol del usuario en la organización
        created_at:
          type: string
          format: date-time
          description: Fecha de creación
        updated_at:
          type: string
          format: date-time
          description: Fecha de última actualización
        name:
          type: string
          description: Nombre del usuario
        email:
          type: string
          format: email
          description: Email del usuario
        image:
          type: string
          description: URL de imagen del usuario
    
    Project:
      type: object
      properties:
        id:
          type: string
          description: ID único del proyecto
        name:
          type: string
          description: Nombre del proyecto
        org_id:
          type: string
          description: ID de la organización propietaria
        created_at:
          type: string
          format: date-time
          description: Fecha de creación
        updated_at:
          type: string
          format: date-time
          description: Fecha de última actualización
    
    ProjectMember:
      type: object
      properties:
        project_id:
          type: string
          description: ID del proyecto
        user_id:
          type: string
          description: ID del usuario
        role:
          type: string
          enum: [OWNER, ADMIN, MEMBER, VIEWER]
          description: Rol del usuario en el proyecto
        created_at:
          type: string
          format: date-time
          description: Fecha de creación
        updated_at:
          type: string
          format: date-time
          description: Fecha de última actualización
        name:
          type: string
          description: Nombre del usuario
        email:
          type: string
          format: email
          description: Email del usuario
        image:
          type: string
          description: URL de imagen del usuario
    
    User:
      type: object
      properties:
        id:
          type: string
          description: ID único del usuario
        name:
          type: string
          description: Nombre del usuario
        email:
          type: string
          format: email
          description: Email del usuario
        image:
          type: string
          description: URL de imagen del usuario
        created_at:
          type: string
          format: date-time
          description: Fecha de creación
        updated_at:
          type: string
          format: date-time
          description: Fecha de última actualización
        admin:
          type: boolean
          description: Si el usuario es administrador global
        feature_flags:
          type: array
          items:
            type: string
          description: Flags de funcionalidades habilitadas para el usuario
    
    UsersList:
      type: object
      properties:
        users:
          type: array
          items:
            $ref: '#/components/schemas/User'
        pagination:
          type: object
          properties:
            total:
              type: integer
              description: Número total de usuarios
            page:
              type: integer
              description: Página actual
            limit:
              type: integer
              description: Límite de resultados por página
            pages:
              type: integer
              description: Número total de páginas
    
    ApiKey:
      type: object
      properties:
        id:
          type: string
          description: ID único de la API key
        created_at:
          type: string
          format: date-time
          description: Fecha de creación
        public_key:
          type: string
          description: Clave pública (para autenticación)
        display_secret_key:
          type: string
          description: Versión truncada de la clave secreta
        last_used_at:
          type: string
          format: date-time
          description: Fecha de último uso
        note:
          type: string
          description: Nota descriptiva (opcional)
        expires_at:
          type: string
          format: date-time
          description: Fecha de expiración (opcional)
    
    NewApiKey:
      allOf:
        - $ref: '#/components/schemas/ApiKey'
        - type: object
          properties:
            secretKey:
              type: string
              description: Clave secreta completa (solo se muestra una vez)
    
    NewProject:
      allOf:
        - $ref: '#/components/schemas/Project'
        - type: object
          properties:
            apiKeys:
              type: object
              properties:
                publicKey:
                  type: string
                  description: Clave pública de API
                secretKey:
                  type: string
                  description: Clave secreta de API (solo se muestra una vez)
    
    HealthStatus:
      type: object
      properties:
        status:
          type: string
          enum: [ok, error]
          description: Estado general del servicio
        timestamp:
          type: string
          format: date-time
          description: Fecha y hora de la verificación
        service:
          type: string
          description: Nombre del servicio
        version:
          type: string
          description: Versión del servicio
        db:
          type: object
          properties:
            status:
              type: string
              enum: [connected, error]
              description: Estado de la conexión a la base de datos
            time:
              type: string
              format: date-time
              description: Fecha y hora del servidor de base de datos

paths:
  /health:
    get:
      summary: Verificar estado del servicio
      description: Verifica el estado del servicio y la conexión a la base de datos
      operationId: checkHealth
      tags: [Monitoring]
      responses:
        '200':
          description: Servicio funcionando correctamente
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HealthStatus'
        '503':
          description: Servicio no disponible
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
  
  /health/db:
    get:
      summary: Verificar estado de la base de datos
      description: Verifica solo el estado de la conexión a la base de datos
      operationId: checkDatabaseHealth
      tags: [Monitoring]
      responses:
        '200':
          description: Base de datos funcionando correctamente
          content:
            application/json:
              schema:
                type: object
                properties:
                  status:
                    type: string
                    enum: [ok]
                  time:
                    type: string
                    format: date-time
                  responseTime:
                    type: string
        '503':
          description: Error de conexión a la base de datos
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
  
  /users:
    get:
      summary: Listar usuarios
      description: Obtiene todos los usuarios con paginación y búsqueda
      operationId: getUsers
      tags: [Users]
      security:
        - ApiKeyAuth: []
      parameters:
        - name: search
          in: query
          schema:
            type: string
          description: Término de búsqueda para nombre o email
        - name: limit
          in: query
          schema:
            type: integer
            default: 10
          description: Límite de resultados por página
        - name: page
          in: query
          schema:
            type: integer
            default: 1
          description: Número de página
      responses:
        '200':
          description: Lista de usuarios
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UsersList'
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
    
    post:
      summary: Crear usuario
      description: Crea un nuevo usuario
      operationId: createUser
      tags: [Users]
      security:
        - ApiKeyAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - name
                - email
              properties:
                name:
                  type: string
                  description: Nombre del usuario
                email:
                  type: string
                  format: email
                  description: Email del usuario
                password:
                  type: string
                  description: Contraseña (opcional)
                admin:
                  type: boolean
                  description: Si el usuario es administrador
      responses:
        '201':
          description: Usuario creado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'
        '400':
          description: Datos inválidos
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '409':
          description: Email ya registrado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
  
  /users/{id}:
    get:
      summary: Obtener usuario
      description: Obtiene un usuario por ID
      operationId: getUserById
      tags: [Users]
      security:
        - ApiKeyAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
          description: ID del usuario
      responses:
        '200':
          description: Datos del usuario
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'
        '404':
          description: Usuario no encontrado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
    
    put:
      summary: Actualizar usuario
      description: Actualiza un usuario existente
      operationId: updateUser
      tags: [Users]
      security:
        - ApiKeyAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
          description: ID del usuario
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                name:
                  type: string
                  description: Nombre del usuario
                email:
                  type: string
                  format: email
                  description: Email del usuario
                image:
                  type: string
                  description: URL de imagen del usuario
                feature_flags:
                  type: array
                  items:
                    type: string
                  description: Flags de funcionalidades
                admin:
                  type: boolean
                  description: Si el usuario es administrador
      responses:
        '200':
          description: Usuario actualizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'
        '400':
          description: Datos inválidos
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '404':
          description: Usuario no encontrado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
    
    delete:
      summary: Eliminar usuario
      description: Elimina un usuario (verificando dependencias)
      operationId: deleteUser
      tags: [Users]
      security:
        - ApiKeyAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
          description: ID del usuario
      responses:
        '200':
          description: Usuario eliminado correctamente
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    description: Mensaje de confirmación
        '400':
          description: No se puede eliminar (tiene dependencias)
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '404':
          description: Usuario no encontrado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
  
  /organizations:
    get:
      summary: Listar organizaciones
      description: Obtiene todas las organizaciones
      operationId: getAllOrganizations
      tags: [Organizations]
      security:
        - ApiKeyAuth: []
      responses:
        '200':
          description: Lista de organizaciones
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Organization'
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
    
    post:
      summary: Crear organización
      description: Crea una nueva organización
      operationId: createOrganization
      tags: [Organizations]
      security:
        - ApiKeyAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - name
                - userId
              properties:
                name:
                  type: string
                  description: Nombre de la organización
                userId:
                  type: string
                  description: ID del usuario que será propietario de la organización
      responses:
        '201':
          description: Organización creada
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Organization'
        '400':
          description: Datos inválidos
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
  
  /organizations/{id}:
    get:
      summary: Obtener organización
      description: Obtiene una organización por ID
      operationId: getOrganizationById
      tags: [Organizations]
      security:
        - ApiKeyAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
          description: ID de la organización
      responses:
        '200':
          description: Datos de la organización
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Organization'
        '404':
          description: Organización no encontrada
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
    
    put:
      summary: Actualizar organización
      description: Actualiza una organización existente
      operationId: updateOrganization
      tags: [Organizations]
      security:
        - ApiKeyAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
          description: ID de la organización
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - name
              properties:
                name:
                  type: string
                  description: Nuevo nombre de la organización
      responses:
        '200':
          description: Organización actualizada
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Organization'
        '400':
          description: Datos inválidos
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '404':
          description: Organización no encontrada
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
  
  /organizations/{id}/members:
    get:
      summary: Listar miembros
      description: Obtiene los miembros de una organización
      operationId: getOrganizationMembers
      tags: [Organization Members]
      security:
        - ApiKeyAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
          description: ID de la organización
      responses:
        '200':
          description: Lista de miembros
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/OrganizationMember'
        '404':
          description: Organización no encontrada
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
    
    post:
      summary: Añadir miembro
      description: Añade un usuario a una organización
      operationId: addOrganizationMember
      tags: [Organization Members]
      security:
        - ApiKeyAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
          description: ID de la organización
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - userId
              properties:
                userId:
                  type: string
                  description: ID del usuario a añadir
                role:
                  type: string
                  enum: [OWNER, ADMIN, VIEWER, NONE]
                  default: VIEWER
                  description: Rol del usuario en la organización
      responses:
        '201':
          description: Usuario añadido a la organización
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/OrganizationMember'
        '400':
          description: Datos inválidos
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '404':
          description: Organización o usuario no encontrado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '409':
          description: El usuario ya es miembro de esta organización
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
  
  /organizations/{orgId}/members/{userId}:
    put:
      summary: Actualizar miembro
      description: Actualiza el rol de un miembro en la organización
      operationId: updateOrganizationMember
      tags: [Organization Members]
      security:
        - ApiKeyAuth: []
      parameters:
        - name: orgId
          in: path
          required: true
          schema:
            type: string
          description: ID de la organización
        - name: userId
          in: path
          required: true
          schema:
            type: string
          description: ID del usuario
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - role
              properties:
                role:
                  type: string
                  enum: [OWNER, ADMIN, VIEWER, NONE]
                  description: Nuevo rol del usuario
      responses:
        '200':
          description: Rol actualizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/OrganizationMember'
        '400':
          description: Datos inválidos o intento de cambiar el rol del último propietario
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '404':
          description: Membresía no encontrada
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
    
    delete:
      summary: Eliminar miembro
      description: Elimina un miembro de la organización
      operationId: removeOrganizationMember
      tags: [Organization Members]
      security:
        - ApiKeyAuth: []
      parameters:
        - name: orgId
          in: path
          required: true
          schema:
            type: string
          description: ID de la organización
        - name: userId
          in: path
          required: true
          schema:
            type: string
          description: ID del usuario
      responses:
        '200':
          description: Miembro eliminado correctamente
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    description: Mensaje de confirmación
        '400':
          description: No se puede eliminar al último propietario
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '404':
          description: Membresía no encontrada
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
  
  /projects:
    get:
      summary: Listar proyectos
      description: Obtiene todos los proyectos (filtrable por organización)
      operationId: getAllProjects
      tags: [Projects]
      security:
        - ApiKeyAuth: []
      parameters:
        - name: orgId
          in: query
          schema:
            type: string
          description: ID de la organización para filtrar (opcional)
      responses:
        '200':
          description: Lista de proyectos
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Project'
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
    
    post:
      summary: Crear proyecto
      description: Crea un nuevo proyecto y genera API keys
      operationId: createProject
      tags: [Projects]
      security:
        - ApiKeyAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - name
                - orgId
              properties:
                name:
                  type: string
                  description: Nombre del proyecto
                orgId:
                  type: string
                  description: ID de la organización
      responses:
        '201':
          description: Proyecto creado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/NewProject'
        '400':
          description: Datos inválidos
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '404':
          description: Organización no encontrada
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
  
  /projects/{id}:
    get:
      summary: Obtener proyecto
      description: Obtiene un proyecto por ID
      operationId: getProjectById
      tags: [Projects]
      security:
        - ApiKeyAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
          description: ID del proyecto
      responses:
        '200':
          description: Datos del proyecto
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Project'
        '404':
          description: Proyecto no encontrado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
    
    put:
      summary: Actualizar proyecto
      description: Actualiza un proyecto existente
      operationId: updateProject
      tags: [Projects]
      security:
        - ApiKeyAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
          description: ID del proyecto
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - name
              properties:
                name:
                  type: string
                  description: Nuevo nombre del proyecto
      responses:
        '200':
          description: Proyecto actualizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Project'
        '400':
          description: Datos inválidos
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '404':
          description: Proyecto no encontrado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
    
    delete:
      summary: Eliminar proyecto
      description: Marca un proyecto como eliminado (soft delete)
      operationId: deleteProject
      tags: [Projects]
      security:
        - ApiKeyAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
          description: ID del proyecto
      responses:
        '200':
          description: Proyecto eliminado correctamente
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    description: Mensaje de confirmación
        '404':
          description: Proyecto no encontrado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
  
  /projects/{projectId}/members:
    get:
      summary: Listar miembros del proyecto
      description: Obtiene todos los miembros de un proyecto
      operationId: getProjectMembers
      tags: [Project Members]
      security:
        - ApiKeyAuth: []
      parameters:
        - name: projectId
          in: path
          required: true
          schema:
            type: string
          description: ID del proyecto
      responses:
        '200':
          description: Lista de miembros
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/ProjectMember'
        '404':
          description: Proyecto no encontrado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
    
    post:
      summary: Añadir miembro al proyecto
      description: Añade un usuario a un proyecto
      operationId: addProjectMember
      tags: [Project Members]
      security:
        - ApiKeyAuth: []
      parameters:
        - name: projectId
          in: path
          required: true
          schema:
            type: string
          description: ID del proyecto
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - userId
              properties:
                userId:
                  type: string
                  description: ID del usuario a añadir
                role:
                  type: string
                  enum: [OWNER, ADMIN, MEMBER, VIEWER]
                  default: VIEWER
                  description: Rol del usuario en el proyecto
      responses:
        '201':
          description: Usuario añadido al proyecto
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProjectMember'
        '400':
          description: Datos inválidos
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '404':
          description: Proyecto o usuario no encontrado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '409':
          description: El usuario ya es miembro de este proyecto
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
  
  /projects/{projectId}/members/batch:
    post:
      summary: Añadir múltiples miembros al proyecto
      description: Añade varios usuarios a un proyecto en una sola operación
      operationId: addBatchProjectMembers
      tags: [Project Members]
      security:
        - ApiKeyAuth: []
      parameters:
        - name: projectId
          in: path
          required: true
          schema:
            type: string
          description: ID del proyecto
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - members
              properties:
                members:
                  type: array
                  items:
                    type: object
                    required:
                      - userId
                    properties:
                      userId:
                        type: string
                        description: ID del usuario
                      role:
                        type: string
                        enum: [OWNER, ADMIN, MEMBER, VIEWER]
                        default: VIEWER
                        description: Rol del usuario
      responses:
        '201':
          description: Resultado de la operación por lotes
          content:
            application/json:
              schema:
                type: object
                properties:
                  success:
                    type: array
                    items:
                      $ref: '#/components/schemas/ProjectMember'
                    description: Miembros añadidos correctamente
                  errors:
                    type: array
                    items:
                      type: object
                      properties:
                        userId:
                          type: string
                        error:
                          type: string
                    description: Errores al añadir miembros
        '400':
          description: Datos inválidos
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '404':
          description: Proyecto no encontrado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
  
  /projects/{projectId}/members/{userId}:
    get:
      summary: Obtener miembro del proyecto
      description: Obtiene detalles de un miembro específico del proyecto
      operationId: getProjectMember
      tags: [Project Members]
      security:
        - ApiKeyAuth: []
      parameters:
        - name: projectId
          in: path
          required: true
          schema:
            type: string
          description: ID del proyecto
        - name: userId
          in: path
          required: true
          schema:
            type: string
          description: ID del usuario
      responses:
        '200':
          description: Datos del miembro
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProjectMember'
        '404':
          description: Membresía no encontrada
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
    
    put:
      summary: Actualizar miembro del proyecto
      description: Actualiza el rol de un miembro en el proyecto
      operationId: updateProjectMember
      tags: [Project Members]
      security:
        - ApiKeyAuth: []
      parameters:
        - name: projectId
          in: path
          required: true
          schema:
            type: string
          description: ID del proyecto
        - name: userId
          in: path
          required: true
          schema:
            type: string
          description: ID del usuario
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - role
              properties:
                role:
                  type: string
                  enum: [OWNER, ADMIN, MEMBER, VIEWER]
                  description: Nuevo rol del usuario
      responses:
        '200':
          description: Rol actualizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProjectMember'
        '400':
          description: Datos inválidos o intento de cambiar el rol del último propietario
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '404':
          description: Membresía no encontrada
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
    
    delete:
      summary: Eliminar miembro del proyecto
      description: Elimina un miembro del proyecto
      operationId: removeProjectMember
      tags: [Project Members]
      security:
        - ApiKeyAuth: []
      parameters:
        - name: projectId
          in: path
          required: true
          schema:
            type: string
          description: ID del proyecto
        - name: userId
          in: path
          required: true
          schema:
            type: string
          description: ID del usuario
      responses:
        '200':
          description: Miembro eliminado correctamente
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    description: Mensaje de confirmación
        '400':
          description: No se puede eliminar al último propietario
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '404':
          description: Membresía no encontrada
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
  
  /projects/{id}/api-keys:
    get:
      summary: Listar API keys
      description: Obtiene las API keys de un proyecto
      operationId: getProjectApiKeys
      tags: [API Keys]
      security:
        - ApiKeyAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
          description: ID del proyecto
      responses:
        '200':
          description: Lista de API keys
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/ApiKey'
        '404':
          description: Proyecto no encontrado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
    
    post:
      summary: Crear API key
      description: Crea una nueva API key para el proyecto
      operationId: createApiKey
      tags: [API Keys]
      security:
        - ApiKeyAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
          description: ID del proyecto
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                note:
                  type: string
                  description: Descripción opcional
                expiresAt:
                  type: string
                  format: date-time
                  description: Fecha de expiración opcional
      responses:
        '201':
          description: API key creada
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/NewApiKey'
        '404':
          description: Proyecto no encontrado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
  
  /api-keys/expired:
    get:
      summary: Listar API keys expiradas
      description: Obtiene todas las API keys que han expirado
      operationId: getExpiredApiKeys
      tags: [API Keys]
      security:
        - ApiKeyAuth: []
      responses:
        '200':
          description: Lista de API keys expiradas
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/ApiKey'
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
    
    delete:
      summary: Eliminar API keys expiradas
      description: Elimina todas las API keys expiradas
      operationId: cleanupExpiredApiKeys
      tags: [API Keys]
      security:
        - ApiKeyAuth: []
      responses:
        '200':
          description: API keys expiradas eliminadas correctamente
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    description: Mensaje de confirmación
                  count:
                    type: integer
                    description: Número de API keys eliminadas
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
  
  /api-keys/{id}:
    get:
      summary: Obtener API key
      description: Obtiene detalles de una API key específica
      operationId: getApiKeyById
      tags: [API Keys]
      security:
        - ApiKeyAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
          description: ID de la API key
      responses:
        '200':
          description: Detalles de la API key
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ApiKey'
        '404':
          description: API key no encontrada
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
    
    delete:
      summary: Eliminar API key
      description: Elimina una API key
      operationId: deleteApiKey
      tags: [API Keys]
      security:
        - ApiKeyAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
          description: ID de la API key
      responses:
        '200':
          description: API key eliminada correctamente
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    description: Mensaje de confirmación
        '404':
          description: API key no encontrada
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
  
  /api-keys/{id}/regenerate:
    post:
      summary: Regenerar API key
      description: Regenera una API key existente
      operationId: regenerateApiKey
      tags: [API Keys]
      security:
        - ApiKeyAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
          description: ID de la API key
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                expiresAt:
                  type: string
                  format: date-time
                  description: Nueva fecha de expiración (opcional)
      responses:
        '200':
          description: API key regenerada
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/NewApiKey'
        '404':
          description: API key no encontrada
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
  
  /api-keys/{id}/expiration:
    put:
      summary: Actualizar expiración de API key
      description: Actualiza la fecha de expiración de una API key
      operationId: updateApiKeyExpiration
      tags: [API Keys]
      security:
        - ApiKeyAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
          description: ID de la API key
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - expiresAt
              properties:
                expiresAt:
                  type: string
                  format: date-time
                  nullable: true
                  description: Nueva fecha de expiración (null para eliminar)
      responses:
        '200':
          description: Expiración actualizada
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ApiKey'
        '400':
          description: Datos inválidos
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '404':
          description: API key no encontrada
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
  
  /api-keys/{id}/note:
    put:
      summary: Actualizar nota de API key
      description: Actualiza la nota descriptiva de una API key
      operationId: updateApiKeyNote
      tags: [API Keys]
      security:
        - ApiKeyAuth: []
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
          description: ID de la API key
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - note
              properties:
                note:
                  type: string
                  description: Nueva nota descriptiva
      responses:
        '200':
          description: Nota actualizada
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ApiKey'
        '404':
          description: API key no encontrada
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '401':
          description: No autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'

tags:
  - name: Organizations
    description: Gestión de organizaciones
  - name: Organization Members
    description: Gestión de miembros de organizaciones
  - name: Projects
    description: Gestión de proyectos
  - name: Project Members
    description: Gestión de miembros de proyectos
  - name: API Keys
    description: Gestión de API keys
  - name: Users
    description: Gestión de usuarios
  - name: Monitoring
    description: Endpoints de monitoreo y salud del servicio

externalDocs:
  description: Documentación adicional
  url: https://docs.langfuse.com

================
File: src/config/database.js
================
'use strict';

/**
 * Configuración de la base de datos
 * Separa los parámetros para evitar duplicación y facilitar cambios
 */

module.exports = {
  host: process.env.DB_HOST || 'localhost',
  port: parseInt(process.env.DB_PORT || '5432'),
  database: process.env.DB_NAME || 'postgres',
  user: process.env.DB_USER || 'postgres',
  password: process.env.DB_PASS || 'postgres',
  ssl: process.env.DB_SSL === 'true' ? { rejectUnauthorized: false } : false,
  
  // Configuración del pool de conexiones
  pool: {
    min: parseInt(process.env.DB_POOL_MIN || '2'),
    max: parseInt(process.env.DB_POOL_MAX || '10'),
    idleTimeoutMillis: parseInt(process.env.DB_IDLE_TIMEOUT || '30000'),
    acquireTimeoutMillis: parseInt(process.env.DB_ACQUIRE_TIMEOUT || '30000'),
  },
  
  // Opciones para migraciones
  migrations: {
    directory: './migrations',
    tableName: 'knex_migrations',
  },
};

================
File: src/config/index.js
================
'use strict';

/**
 * Configuración centralizada de la aplicación
 * Facilita la gestión de variables de entorno y valores por defecto
 */

// Importar configuración específica de componentes
const database = require('./database');

// Normalización de variables de entorno
const env = (key, defaultValue = undefined) => {
  const value = process.env[key];
  if (value === undefined) {
    if (defaultValue === undefined) {
      throw new Error(`Variable de entorno ${key} no definida`);
    }
    return defaultValue;
  }
  return value;
};

// Normalización de variables booleanas
const boolEnv = (key, defaultValue = undefined) => {
  const value = env(key, defaultValue);
  return value === 'true' || value === '1' || value === 'yes';
};

// Normalización de variables numéricas
const numEnv = (key, defaultValue = undefined) => {
  const value = env(key, defaultValue);
  return Number(value);
};

// Configuración general de la aplicación
const config = {
  // Entorno
  nodeEnv: env('NODE_ENV', 'development'),
  isProduction: env('NODE_ENV', 'development') === 'production',
  isDevelopment: env('NODE_ENV', 'development') === 'development',
  isTest: env('NODE_ENV', 'development') === 'test',

  // Servidor HTTP
  port: numEnv('PORT', 3100),
  host: env('HOST', '0.0.0.0'),
  
  // Seguridad
  apiKey: env('API_KEY', 'admin-secret-key'),
  enableApiKeyAuth: boolEnv('ENABLE_API_KEY_AUTH', true),
  
  // Logging
  logLevel: env('LOG_LEVEL', 'info'),
  enableRequestLogging: boolEnv('ENABLE_REQUEST_LOGGING', true),

  // CORS
  corsOrigin: env('CORS_ORIGIN', '*'),
  
  // Rate limiting
  rateLimit: {
    windowMs: numEnv('RATE_LIMIT_WINDOW_MS', 15 * 60 * 1000), // 15 minutos
    max: numEnv('RATE_LIMIT_MAX', 100), // Máximo de solicitudes por IP
  },
  
  // Documentación
  enableDocs: boolEnv('ENABLE_DOCS', true),

  // Base de datos
  db: database,
};

module.exports = config;

================
File: src/controllers/api-keys.controller.js
================
'use strict';

const { asyncHandler } = require('../middleware/error.middleware');
const { NotFoundError } = require('../utils/errors');
const apiKeysService = require('../services/api-keys.service');
const { createContextLogger } = require('../utils/logger');

// Logger contextual para este controlador
const logger = createContextLogger('api-keys-controller');

/**
 * @route GET /api/projects/:id/api-keys
 * @description Listar todas las API keys de un proyecto
 */
const getProjectApiKeys = asyncHandler(async (req, res) => {
  const { id: projectId } = req.params;
  logger.info(`Obteniendo API keys para proyecto: ${projectId}`);
  
  const apiKeys = await apiKeysService.getByProject(projectId);
  
  res.json(apiKeys);
});

/**
 * @route GET /api/api-keys/:id
 * @description Obtener detalles de una API key
 */
const getApiKeyById = asyncHandler(async (req, res) => {
  const { id } = req.params;
  logger.info(`Obteniendo detalles de API key: ${id}`);
  
  const apiKey = await apiKeysService.getById(id);
  
  res.json(apiKey);
});

/**
 * @route POST /api/projects/:id/api-keys
 * @description Crear una nueva API key para un proyecto
 */
const createApiKey = asyncHandler(async (req, res) => {
  const { id: projectId } = req.params;
  const { note, expiresAt } = req.body;
  logger.info(`Creando nueva API key para proyecto: ${projectId}`);
  
  const newApiKey = await apiKeysService.create(projectId, { note, expiresAt });
  
  res.status(201).json(newApiKey);
});

/**
 * @route POST /api/api-keys/:id/regenerate
 * @description Regenerar una API key existente
 */
const regenerateApiKey = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { expiresAt } = req.body;
  logger.info(`Regenerando API key: ${id}`);
  
  const regeneratedApiKey = await apiKeysService.regenerate(id, { expiresAt });
  
  res.json(regeneratedApiKey);
});

/**
 * @route PUT /api/api-keys/:id/expiration
 * @description Actualizar la fecha de expiración de una API key
 */
const updateApiKeyExpiration = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { expiresAt } = req.body;
  logger.info(`Actualizando expiración de API key: ${id}`);
  
  const apiKey = await apiKeysService.updateExpiration(id, expiresAt);
  
  res.json(apiKey);
});

/**
 * @route PUT /api/api-keys/:id/note
 * @description Actualizar la nota de una API key
 */
const updateApiKeyNote = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { note } = req.body;
  logger.info(`Actualizando nota de API key: ${id}`);
  
  const apiKey = await apiKeysService.updateNote(id, note);
  
  res.json(apiKey);
});

/**
 * @route DELETE /api/api-keys/:id
 * @description Eliminar una API key
 */
const deleteApiKey = asyncHandler(async (req, res) => {
  const { id } = req.params;
  logger.info(`Eliminando API key: ${id}`);
  
  await apiKeysService.delete(id);
  
  res.json({ message: 'API key eliminada correctamente' });
});

/**
 * @route GET /api/api-keys/expired
 * @description Listar todas las API keys expiradas
 */
const getExpiredApiKeys = asyncHandler(async (req, res) => {
  logger.info('Obteniendo API keys expiradas');
  
  const expiredKeys = await apiKeysService.getExpired();
  
  res.json(expiredKeys);
});

/**
 * @route DELETE /api/api-keys/expired
 * @description Eliminar todas las API keys expiradas
 */
const cleanupExpiredApiKeys = asyncHandler(async (req, res) => {
  logger.info('Eliminando API keys expiradas');
  
  const count = await apiKeysService.cleanupExpired();
  
  res.json({ 
    message: `${count} API keys expiradas eliminadas correctamente`,
    count
  });
});

module.exports = {
  getProjectApiKeys,
  getApiKeyById,
  createApiKey,
  deleteApiKey,
  regenerateApiKey,
  updateApiKeyExpiration,
  updateApiKeyNote,
  getExpiredApiKeys,
  cleanupExpiredApiKeys
};

================
File: src/controllers/health.controller.js
================
'use strict';

const { asyncHandler } = require('../middleware/error.middleware');
const { db } = require('../services/database.service');
const { createContextLogger } = require('../utils/logger');
const packageInfo = require('../../package.json');

// Logger contextual para este controlador
const logger = createContextLogger('health-controller');

/**
 * @route GET /api/health
 * @description Verificar estado del servicio y conexión a la base de datos
 */
const checkHealth = asyncHandler(async (req, res) => {
  logger.debug('Verificando estado del servicio');
  
  // Estado general del servicio
  const healthCheck = {
    status: 'ok',
    timestamp: new Date(),
    uptime: Math.floor(process.uptime()),
    service: packageInfo.name,
    version: packageInfo.version,
    environment: process.env.NODE_ENV || 'development',
    memory: process.memoryUsage(),
  };
  
  // Verificar base de datos
  try {
    // Use the checkConnection method from the database service
    const dbStatus = await db.checkConnection();
    
    if (dbStatus.status === 'connected') {
      healthCheck.db = {
        status: 'connected',
        time: dbStatus.time,
      };
    } else {
      healthCheck.db = {
        status: 'error',
        error: process.env.NODE_ENV === 'production' 
          ? 'Error de conexión' 
          : dbStatus.error,
        code: dbStatus.code
      };
      healthCheck.status = 'error';
      
      logger.error('Error al verificar base de datos:', dbStatus);
      return res.status(503).json(healthCheck);
    }
  } catch (error) {
    logger.error('Error al verificar base de datos:', error);
    healthCheck.db = {
      status: 'error',
      error: process.env.NODE_ENV === 'production' 
        ? 'Error de conexión' 
        : error.message,
      code: error.code
    };
    healthCheck.status = 'error';
    
    // En caso de error en BD, respondemos con código 503
    return res.status(503).json(healthCheck);
  }
  
  // Agregar información de sistema (no exponer en producción)
  if (process.env.NODE_ENV !== 'production') {
    healthCheck.system = {
      nodeVersion: process.version,
      platform: process.platform,
      cpuUsage: process.cpuUsage(),
    };
  }
  
  // Responder con estado completo
  res.json(healthCheck);
});

/**
 * @route GET /api/health/db
 * @description Verificar solo el estado de la base de datos
 */
const checkDatabaseHealth = asyncHandler(async (req, res) => {
  logger.debug('Verificando estado de la base de datos');
  
  try {
    // Use the checkConnection method from the database service
    const dbStatus = await db.checkConnection();
    
    if (dbStatus.status === 'connected') {
      res.json({
        status: 'ok',
        time: dbStatus.time,
        responseTime: dbStatus.responseTime || 'N/A',
      });
    } else {
      logger.error('Error al verificar base de datos:', dbStatus);
      
      res.status(503).json({
        status: 'error',
        message: 'Error de conexión a la base de datos',
        error: process.env.NODE_ENV === 'production' ? undefined : dbStatus.error,
        code: dbStatus.code
      });
    }
  } catch (error) {
    logger.error('Error al verificar base de datos:', error);
    
    res.status(503).json({
      status: 'error',
      message: 'Error de conexión a la base de datos',
      error: process.env.NODE_ENV === 'production' ? undefined : error.message,
      code: error.code
    });
  }
});

module.exports = {
  checkHealth,
  checkDatabaseHealth
};

================
File: src/controllers/organizations.controller.js
================
'use strict';

const { asyncHandler } = require('../middleware/error.middleware');
const { NotFoundError } = require('../utils/errors');
const organizationsService = require('../services/organizations.service');
const { createContextLogger } = require('../utils/logger');

// Logger contextual para este controlador
const logger = createContextLogger('organizations-controller');

/**
 * @route GET /api/organizations
 * @description Listar todas las organizaciones
 */
const getAllOrganizations = asyncHandler(async (req, res) => {
  logger.info('Obteniendo lista de organizaciones');
  
  const organizations = await organizationsService.getAll();
  
  res.json(organizations);
});

/**
 * @route GET /api/organizations/:id
 * @description Obtener una organización por ID
 */
const getOrganizationById = asyncHandler(async (req, res) => {
  const { id } = req.params;
  logger.info(`Obteniendo organización con ID: ${id}`);
  
  const organization = await organizationsService.getById(id);
  
  if (!organization) {
    throw new NotFoundError('Organización');
  }
  
  res.json(organization);
});

/**
 * @route POST /api/organizations
 * @description Crear una nueva organización con un usuario propietario
 */
const createOrganization = asyncHandler(async (req, res) => {
  const { name, userId } = req.body;
  logger.info(`Creando nueva organización: ${name} con propietario: ${userId}`);
  
  const newOrganization = await organizationsService.create({ name, userId });
  
  res.status(201).json(newOrganization);
});

/**
 * @route PUT /api/organizations/:id
 * @description Actualizar una organización existente
 */
const updateOrganization = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { name } = req.body;
  logger.info(`Actualizando organización con ID: ${id}`);
  
  const updatedOrganization = await organizationsService.update(id, { name });
  
  if (!updatedOrganization) {
    throw new NotFoundError('Organización');
  }
  
  res.json(updatedOrganization);
});

/**
 * @route GET /api/organizations/:id/members
 * @description Obtener miembros de una organización
 */
const getOrganizationMembers = asyncHandler(async (req, res) => {
  const { id } = req.params;
  logger.info(`Obteniendo miembros de organización con ID: ${id}`);
  
  const members = await organizationsService.getMembers(id);
  
  res.json(members);
});

/**
 * @route POST /api/organizations/:id/members
 * @description Añadir un usuario a una organización
 */
const addOrganizationMember = asyncHandler(async (req, res) => {
  const { id: orgId } = req.params;
  const { userId, role = 'VIEWER' } = req.body;
  logger.info(`Añadiendo usuario ${userId} a organización ${orgId} con rol ${role}`);
  
  const member = await organizationsService.addMember(orgId, userId, role);
  
  res.status(201).json(member);
});

/**
 * @route PUT /api/organizations/:orgId/members/:userId
 * @description Actualizar rol de un miembro en la organización
 */
const updateOrganizationMember = asyncHandler(async (req, res) => {
  const { orgId, userId } = req.params;
  const { role } = req.body;
  logger.info(`Actualizando rol de usuario ${userId} en organización ${orgId} a ${role}`);
  
  const member = await organizationsService.updateMember(orgId, userId, role);
  
  res.json(member);
});

/**
 * @route DELETE /api/organizations/:orgId/members/:userId
 * @description Eliminar un miembro de la organización
 */
const removeOrganizationMember = asyncHandler(async (req, res) => {
  const { orgId, userId } = req.params;
  logger.info(`Eliminando usuario ${userId} de organización ${orgId}`);
  
  await organizationsService.removeMember(orgId, userId);
  
  res.json({ message: 'Miembro eliminado correctamente' });
});

module.exports = {
  getAllOrganizations,
  getOrganizationById,
  createOrganization,
  updateOrganization,
  getOrganizationMembers,
  addOrganizationMember,
  updateOrganizationMember,
  removeOrganizationMember
};

================
File: src/controllers/project-memberships.controller.js
================
'use strict';

const { asyncHandler } = require('../middleware/error.middleware');
const { NotFoundError } = require('../utils/errors');
const projectMembershipsService = require('../services/project-memberships.service');
const { createContextLogger } = require('../utils/logger');

// Logger contextual para este controlador
const logger = createContextLogger('project-memberships-controller');

/**
 * @route GET /api/projects/:projectId/members
 * @description Listar todos los miembros de un proyecto
 */
const getProjectMembers = asyncHandler(async (req, res) => {
  const { projectId } = req.params;
  logger.info(`Obteniendo miembros del proyecto: ${projectId}`);
  
  const members = await projectMembershipsService.getByProject(projectId);
  
  res.json(members);
});

/**
 * @route POST /api/projects/:projectId/members
 * @description Añadir un miembro a un proyecto
 */
const addProjectMember = asyncHandler(async (req, res) => {
  const { projectId } = req.params;
  const { userId, role = 'VIEWER' } = req.body;
  logger.info(`Añadiendo usuario ${userId} al proyecto ${projectId} con rol ${role}`);
  
  const membership = await projectMembershipsService.addMember(projectId, userId, role);
  
  res.status(201).json(membership);
});

/**
 * @route GET /api/projects/:projectId/members/:userId
 * @description Obtener detalles de un miembro específico del proyecto
 */
const getProjectMember = asyncHandler(async (req, res) => {
  const { projectId, userId } = req.params;
  logger.info(`Obteniendo detalles de membresía: ${userId} en proyecto ${projectId}`);
  
  const membership = await projectMembershipsService.getMember(projectId, userId);
  
  if (!membership) {
    throw new NotFoundError('Membresía de proyecto');
  }
  
  res.json(membership);
});

/**
 * @route PUT /api/projects/:projectId/members/:userId
 * @description Actualizar rol de un miembro en el proyecto
 */
const updateProjectMember = asyncHandler(async (req, res) => {
  const { projectId, userId } = req.params;
  const { role } = req.body;
  logger.info(`Actualizando rol de usuario ${userId} en proyecto ${projectId} a ${role}`);
  
  const membership = await projectMembershipsService.updateMember(projectId, userId, role);
  
  res.json(membership);
});

/**
 * @route DELETE /api/projects/:projectId/members/:userId
 * @description Eliminar un miembro del proyecto
 */
const removeProjectMember = asyncHandler(async (req, res) => {
  const { projectId, userId } = req.params;
  logger.info(`Eliminando usuario ${userId} del proyecto ${projectId}`);
  
  await projectMembershipsService.removeMember(projectId, userId);
  
  res.json({ message: 'Miembro eliminado correctamente del proyecto' });
});

/**
 * @route POST /api/projects/:projectId/members/batch
 * @description Añadir múltiples miembros a un proyecto
 */
const addBatchProjectMembers = asyncHandler(async (req, res) => {
  const { projectId } = req.params;
  const { members } = req.body;
  logger.info(`Añadiendo ${members.length} miembros al proyecto ${projectId}`);
  
  const result = await projectMembershipsService.addBatchMembers(projectId, members);
  
  res.status(201).json(result);
});

module.exports = {
  getProjectMembers,
  addProjectMember,
  getProjectMember,
  updateProjectMember,
  removeProjectMember,
  addBatchProjectMembers
};

================
File: src/controllers/projects.controller.js
================
'use strict';

const { asyncHandler } = require('../middleware/error.middleware');
const { NotFoundError } = require('../utils/errors');
const projectsService = require('../services/projects.service');
const { createContextLogger } = require('../utils/logger');

// Logger contextual para este controlador
const logger = createContextLogger('projects-controller');

/**
 * @route GET /api/projects
 * @description Listar todos los proyectos (filtrable por organización)
 */
const getAllProjects = asyncHandler(async (req, res) => {
  const { orgId } = req.query;
  logger.info(`Obteniendo lista de proyectos${orgId ? ` para organización ${orgId}` : ''}`);
  
  const projects = await projectsService.getAll(orgId);
  
  res.json(projects);
});

/**
 * @route GET /api/projects/:id
 * @description Obtener un proyecto por ID
 */
const getProjectById = asyncHandler(async (req, res) => {
  const { id } = req.params;
  logger.info(`Obteniendo proyecto con ID: ${id}`);
  
  const project = await projectsService.getById(id);
  
  if (!project) {
    throw new NotFoundError('Proyecto');
  }
  
  res.json(project);
});

/**
 * @route POST /api/projects
 * @description Crear un nuevo proyecto y generar API keys
 */
const createProject = asyncHandler(async (req, res) => {
  const { name, orgId } = req.body;
  logger.info(`Creando nuevo proyecto en organización ${orgId}`);
  
  const newProject = await projectsService.create({ name, orgId });
  
  res.status(201).json(newProject);
});

/**
 * @route PUT /api/projects/:id
 * @description Actualizar un proyecto existente
 */
const updateProject = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { name } = req.body;
  logger.info(`Actualizando proyecto con ID: ${id}`);
  
  const updatedProject = await projectsService.update(id, { name });
  
  if (!updatedProject) {
    throw new NotFoundError('Proyecto');
  }
  
  res.json(updatedProject);
});

/**
 * @route DELETE /api/projects/:id
 * @description Marcar un proyecto como eliminado (soft delete)
 */
const deleteProject = asyncHandler(async (req, res) => {
  const { id } = req.params;
  logger.info(`Eliminando proyecto con ID: ${id}`);
  
  await projectsService.delete(id);
  
  res.json({ message: 'Proyecto eliminado correctamente' });
});

module.exports = {
  getAllProjects,
  getProjectById,
  createProject,
  updateProject,
  deleteProject
};

================
File: src/controllers/users.controller.js
================
'use strict';

const { asyncHandler } = require('../middleware/error.middleware');
const { NotFoundError } = require('../utils/errors');
const { db } = require('../services/database.service');
const { createContextLogger } = require('../utils/logger');
const usersService = require('../services/users.service');

// Logger contextual para este controlador
const logger = createContextLogger('users-controller');

/**
 * @route GET /api/users
 * @description Listar usuarios disponibles (para asignar a organizaciones)
 */
const getUsers = asyncHandler(async (req, res) => {
  const { search, limit = 10, page = 1 } = req.query;
  logger.info('Obteniendo lista de usuarios');
  
  const users = await usersService.getAll({ search, limit, page });
  
  res.json(users);
});

/**
 * @route GET /api/users/:id
 * @description Obtener detalles de un usuario específico
 */
const getUserById = asyncHandler(async (req, res) => {
  const { id } = req.params;
  logger.info(`Obteniendo usuario con ID: ${id}`);
  
  const user = await usersService.getById(id);
  
  if (!user) {
    throw new NotFoundError('Usuario');
  }
  
  res.json(user);
});

/**
 * @route POST /api/users
 * @description Crear un nuevo usuario
 */
const createUser = asyncHandler(async (req, res) => {
  const { name, email, password } = req.body;
  logger.info(`Creando nuevo usuario: ${email}`);
  
  const newUser = await usersService.create({ 
    name, 
    email, 
    password
  });
  
  res.status(201).json(newUser);
});

/**
 * @route PUT /api/users/:id
 * @description Actualizar un usuario existente
 */
const updateUser = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { name, email, image, feature_flags, admin } = req.body;
  logger.info(`Actualizando usuario con ID: ${id}`);
  
  const updatedUser = await usersService.update(id, { 
    name, 
    email, 
    image, 
    feature_flags, 
    admin 
  });
  
  if (!updatedUser) {
    throw new NotFoundError('Usuario');
  }
  
  res.json(updatedUser);
});

/**
 * @route DELETE /api/users/:id
 * @description Eliminar un usuario (verificando dependencias)
 */
const deleteUser = asyncHandler(async (req, res) => {
  const { id } = req.params;
  logger.info(`Eliminando usuario con ID: ${id}`);
  
  await usersService.delete(id);
  
  res.json({ message: 'Usuario eliminado correctamente' });
});

module.exports = {
  getUsers,
  getUserById,
  createUser,
  updateUser,
  deleteUser
};

================
File: src/middleware/auth.middleware.js
================
'use strict';

const crypto = require('crypto');
const config = require('../config');
const { AuthenticationError, AuthorizationError } = require('../utils/errors');
const { db } = require('../services/database.service'); // Fix: Import db directly
const { logger } = require('../utils/logger');

/**
 * Middleware para validar la API key administrativa
 */
const validateAdminApiKey = (req, res, next) => {
  if (!config.enableApiKeyAuth) {
    return next();
  }
  
  const apiKey = req.headers['x-api-key'];
  
  if (!apiKey || apiKey !== config.apiKey) {
    return next(new AuthenticationError('API Key inválida'));
  }
  
  // Para simplificar el acceso administrativo, asumimos un usuario administrador
  req.user = {
    id: 'admin',
    role: 'ADMIN'
  };
  
  next();
};

/**
 * Middleware para validar API keys de proyectos
 * Verifica la autenticación para APIs de integración
 */
const validateProjectApiKey = async (req, res, next) => {
  const publicKey = req.headers['x-api-key'];
  const secretKey = req.headers['x-api-secret'];
  
  if (!publicKey || !secretKey) {
    return next(new AuthenticationError('Se requieren API keys'));
  }
  
  try {
    // Buscar la API key por su clave pública
    // Fix: Use db.queryOne instead of dbService.queryOne
    const apiKey = await db.queryOne(
      'SELECT project_id, hashed_secret_key FROM api_keys WHERE public_key = $1',
      [publicKey]
    );
    
    if (!apiKey) {
      return next(new AuthenticationError('API key no encontrada'));
    }
    
    // Verificar la clave secreta hasheada
    const hashedSecret = crypto.createHash('sha256').update("salt" + secretKey).digest('hex');
    
    if (hashedSecret !== apiKey.hashed_secret_key) {
      return next(new AuthenticationError('Clave secreta inválida'));
    }
    
    // Buscar el proyecto
    // Fix: Use db.queryOne instead of dbService.queryOne
    const project = await db.queryOne(
      'SELECT id, org_id, deleted_at FROM projects WHERE id = $1',
      [apiKey.project_id]
    );
    
    if (!project || project.deleted_at) {
      return next(new AuthenticationError('Proyecto inactivo o eliminado'));
    }
    
    // Actualizar último uso de la API key
    // Fix: Use db.query instead of dbService.query
    await db.query(
      'UPDATE api_keys SET last_used_at = CURRENT_TIMESTAMP WHERE public_key = $1',
      [publicKey]
    );
    
    // Adjuntar información del proyecto a la solicitud
    req.project = project;
    
    next();
  } catch (error) {
    logger.error('Error al validar API key de proyecto:', error);
    return next(new AuthenticationError('Error al validar credenciales'));
  }
};

/**
 * Middleware para verificar roles en la organización
 * @param {string[]} allowedRoles - Roles permitidos
 */
const requireOrgRole = (allowedRoles = ['OWNER', 'ADMIN']) => {
  return async (req, res, next) => {
    // En una API administrativa simplificada, asumimos que el usuario tiene permisos
    // Ya que se ha autenticado con la API key administrativa
    next();
  };
};

module.exports = {
  validateAdminApiKey,
  validateProjectApiKey,
  requireOrgRole
};

================
File: src/middleware/error.middleware.js
================
'use strict';

const { AppError } = require('../utils/errors');
const { logger } = require('../utils/logger');

/**
 * Middleware for capturing errors in async/await controllers
 * Wraps controllers with a try/catch and passes the error to the next middleware
 */
const asyncHandler = (fn) => (req, res, next) => {
  Promise.resolve(fn(req, res, next)).catch(next);
};

/**
 * Central middleware to handle all application errors
 */
const errorHandler = (err, req, res, next) => {
  // Application errors vs third-party errors
  if (err instanceof AppError) {
    const statusCode = err.status;
    
    // Log based on severity
    if (statusCode >= 500) {
      logger.error('Application error:', {
        error: err.message,
        stack: err.stack,
        code: err.code,
        details: err.details
      });
    } else {
      logger.warn('Client error:', {
        error: err.message,
        code: err.code,
        details: err.details
      });
    }
    
    return res.status(statusCode).json(err.toJSON());
  }
  
  // Express and other library errors
  let statusCode = 500;
  let errorMessage = 'Internal server error';
  let errorCode = 'INTERNAL_SERVER_ERROR';
  
  // Known specific errors
  if (err.name === 'SyntaxError' && err.status === 400) {
    statusCode = 400;
    errorMessage = 'Invalid JSON format';
    errorCode = 'INVALID_JSON';
  } else if (err.code === 'ECONNREFUSED' || err.code === 'ENOTFOUND') {
    statusCode = 503;
    errorMessage = 'Service temporarily unavailable';
    errorCode = 'SERVICE_UNAVAILABLE';
  }
  
  // Log error
  logger.error('Unhandled error:', {
    error: err.message,
    stack: err.stack,
    type: err.name,
    code: err.code
  });
  
  // Response to client
  const response = {
    error: errorCode,
    message: errorMessage
  };
  
  if (process.env.NODE_ENV !== 'production') {
    response.details = {
      name: err.name,
      message: err.message,
      stack: err.stack?.split('\n')
    };
  }
  
  return res.status(statusCode).json(response);
};

module.exports = {
  asyncHandler,
  errorHandler
};

================
File: src/middleware/request.middleware.js
================
'use strict';

const { v4: uuidv4 } = require('uuid');
const { logger } = require('../utils/logger');
const config = require('../config');

/**
 * Middleware para logging estructurado de solicitudes HTTP
 * Asigna un ID único a cada solicitud para seguimiento
 */
const requestLogger = (req, res, next) => {
  // Omitir logging en test o si está desactivado
  if (config.isTest || !config.enableRequestLogging) {
    return next();
  }
  
  // Generar un ID único para la solicitud
  req.id = uuidv4();
  res.setHeader('X-Request-ID', req.id);
  
  // Capturar tiempo de inicio
  const start = Date.now();
  
  // Registrar datos de la solicitud
  const logData = {
    id: req.id,
    method: req.method,
    url: req.originalUrl || req.url,
    ip: req.ip || req.connection.remoteAddress,
    userAgent: req.get('user-agent') || 'unknown',
  };
  
  // Log de la solicitud de entrada
  logger.info(`Solicitud recibida: ${req.method} ${req.originalUrl}`, logData);
  
  // Capturar cuando finalice la respuesta
  res.on('finish', () => {
    // Calcular duración
    const duration = Date.now() - start;
    
    // Añadir datos de respuesta
    logData.statusCode = res.statusCode;
    logData.duration = duration;
    
    // Nivel de log según el código de estado
    const message = `Respuesta: ${res.statusCode} ${req.method} ${req.originalUrl} (${duration}ms)`;
    
    if (res.statusCode >= 500) {
      logger.error(message, logData);
    } else if (res.statusCode >= 400) {
      logger.warn(message, logData);
    } else {
      logger.info(message, logData);
    }
  });
  
  next();
};

module.exports = {
  requestLogger
};

================
File: src/middleware/validation.middleware.js
================
'use strict';

const Joi = require('joi');
const { ValidationError } = require('../utils/errors');

/**
 * Middleware para validar solicitudes
 * @param {Object} schema - Esquema de validación Joi para body, query y params
 * @returns {Function} - Middleware de validación
 */
const validate = (schema) => {
  return (req, res, next) => {
    // Objeto para almacenar los errores
    const validationErrors = {};
    
    // Validar body si hay un esquema definido
    if (schema.body) {
      const { error } = schema.body.validate(req.body, { abortEarly: false });
      if (error) {
        validationErrors.body = formatJoiErrors(error);
      }
    }
    
    // Validar query params si hay un esquema definido
    if (schema.query) {
      const { error } = schema.query.validate(req.query, { abortEarly: false });
      if (error) {
        validationErrors.query = formatJoiErrors(error);
      }
    }
    
    // Validar path params si hay un esquema definido
    if (schema.params) {
      const { error } = schema.params.validate(req.params, { abortEarly: false });
      if (error) {
        validationErrors.params = formatJoiErrors(error);
      }
    }
    
    // Si hay errores, lanzar error de validación
    if (Object.keys(validationErrors).length > 0) {
      return next(new ValidationError('Error de validación', validationErrors));
    }
    
    next();
  };
};

/**
 * Formatea los errores de Joi en un formato más amigable
 * @param {Object} error - Error de validación de Joi
 * @returns {Object} - Errores formateados
 */
function formatJoiErrors(error) {
  return error.details.reduce((acc, detail) => {
    // Extraer el nombre del campo y quitar corchetes
    const key = detail.path.join('.');
    
    // Formatear mensajes para ser más legibles
    let message = detail.message.replace(/['"]/g, '');
    
    // Mensajes más amigables para casos comunes
    if (message.includes('is required')) {
      message = 'Este campo es requerido';
    } else if (message.includes('must be a valid')) {
      message = 'Formato inválido';
    }
    
    acc[key] = message;
    return acc;
  }, {});
}

/**
 * Esquema genérico para validar ID
 * Ahora soporta tanto IDs en formato prefijo_base (como 'org_12345') como cuid (como 'cm84umiqf001bpp07fzmk5q26')
 */
const idSchema = Joi.string().pattern(/(^[a-z]+_[a-z0-9]+$)|(^c[a-z0-9]+$)/);

/**
 * Esquemas comunes reutilizables
 */
const commonSchemas = {
  id: idSchema,
  uuid: Joi.string().uuid(),
  email: Joi.string().email(),
  name: Joi.string().min(2).max(100),
  pagination: Joi.object({
    page: Joi.number().integer().min(1).default(1),
    limit: Joi.number().integer().min(1).max(100).default(20),
  }),
  orgRole: Joi.string().valid('OWNER', 'ADMIN', 'VIEWER', 'NONE'),
};

module.exports = {
  validate,
  commonSchemas,
  Joi, // Exportar Joi para definir esquemas en los controladores
};

================
File: src/routes/api-keys.routes.js
================
'use strict';

const express = require('express');
const router = express.Router();
const { validate, Joi, commonSchemas } = require('../middleware/validation.middleware');
const apiKeysController = require('../controllers/api-keys.controller');
const { NotFoundError } = require('../utils/errors');
const { db } = require('../services/database.service');

// Esquemas de validación
const schemas = {
  idParam: Joi.object({
    id: commonSchemas.id.required()
      .messages({
        'any.required': 'El ID de API key es requerido'
      }),
  }),
  
  createApiKey: Joi.object({
    note: Joi.string().trim().allow('').max(255).optional()
      .messages({
        'string.max': 'La nota no puede exceder {#limit} caracteres'
      }),
    expiresAt: Joi.date().iso().min('now').optional()
      .messages({
        'date.base': 'Fecha de expiración inválida',
        'date.min': 'La fecha de expiración debe ser futura'
      })
  }),
  
  regenerateApiKey: Joi.object({
    expiresAt: Joi.date().iso().min('now').allow(null).optional()
      .messages({
        'date.base': 'Fecha de expiración inválida',
        'date.min': 'La fecha de expiración debe ser futura'
      })
  }),
  
  updateExpiration: Joi.object({
    expiresAt: Joi.date().iso().min('now').allow(null).required()
      .messages({
        'date.base': 'Fecha de expiración inválida',
        'date.min': 'La fecha de expiración debe ser futura',
        'any.required': 'La fecha de expiración es requerida'
      })
  }),
  
  updateNote: Joi.object({
    note: Joi.string().trim().allow('').max(255).required()
      .messages({
        'string.max': 'La nota no puede exceder {#limit} caracteres',
        'any.required': 'La nota es requerida'
      })
  })
};

// Middleware para verificar que una API key existe
const checkApiKeyExists = async (req, res, next) => {
  try {
    const { id } = req.params;
    const apiKeyInfo = await db.queryOne(
      `SELECT ak.id 
       FROM api_keys ak
       JOIN projects p ON ak.project_id = p.id 
       WHERE ak.id = $1 AND p.deleted_at IS NULL`,
      [id]
    );
    
    if (!apiKeyInfo) {
      throw new NotFoundError('API key');
    }
    
    next();
  } catch (error) {
    next(error);
  }
};

// Rutas específicas para API keys
router.get('/expired', apiKeysController.getExpiredApiKeys);
router.delete('/expired', apiKeysController.cleanupExpiredApiKeys);

// Rutas para obtener/eliminar/actualizar API keys específicas
router.get('/:id', 
  validate({ params: schemas.idParam }),
  apiKeysController.getApiKeyById
);

router.post('/:id/regenerate', 
  validate({ params: schemas.idParam, body: schemas.regenerateApiKey }),
  checkApiKeyExists,
  apiKeysController.regenerateApiKey
);

router.put('/:id/expiration', 
  validate({ params: schemas.idParam, body: schemas.updateExpiration }),
  checkApiKeyExists,
  apiKeysController.updateApiKeyExpiration
);

router.put('/:id/note', 
  validate({ params: schemas.idParam, body: schemas.updateNote }),
  checkApiKeyExists,
  apiKeysController.updateApiKeyNote
);

router.delete('/:id', 
  validate({ params: schemas.idParam }),
  checkApiKeyExists,
  apiKeysController.deleteApiKey
);

module.exports = router;

================
File: src/routes/health.routes.js
================
'use strict';

const express = require('express');
const router = express.Router();
const healthController = require('../controllers/health.controller');

/**
 * Rutas para monitoreo de estado del servicio
 * Estas rutas no requieren autenticación para permitir monitoreo externo
 */

// Estado general del servicio
router.get('/', healthController.checkHealth);

// Estado específico de la base de datos
router.get('/db', healthController.checkDatabaseHealth);

module.exports = router;

================
File: src/routes/index.js
================
'use strict';

const express = require('express');
const router = express.Router();
const { validateAdminApiKey } = require('../middleware/auth.middleware');

// Importar rutas específicas
const organizationsRoutes = require('./organizations.routes');
const projectsRoutes = require('./projects.routes');
const usersRoutes = require('./users.routes');
const apiKeysRoutes = require('./api-keys.routes');
const healthRoutes = require('./health.routes');

// Endpoint de estado (no requiere autenticación)
router.use('/health', healthRoutes);

// Rutas protegidas por API key administrativa
// Este es el único punto de autenticación necesario
router.use(validateAdminApiKey);

// Rutas para cada recurso
router.use('/organizations', organizationsRoutes);
router.use('/projects', projectsRoutes);
router.use('/users', usersRoutes);
router.use('/api-keys', apiKeysRoutes);

module.exports = router;

================
File: src/routes/organizations.routes.js
================
'use strict';

const express = require('express');
const router = express.Router();
const { validate, Joi, commonSchemas } = require('../middleware/validation.middleware');
const { requireOrgRole } = require('../middleware/auth.middleware');
const organizationsController = require('../controllers/organizations.controller');

// Esquemas de validación
const schemas = {
  idParam: Joi.object({
    id: commonSchemas.id.required(),
  }),
  
  orgIdUserIdParams: Joi.object({
    orgId: commonSchemas.id.required(),
    userId: commonSchemas.id.required(),
  }),
  
  createOrg: Joi.object({
    name: Joi.string().trim().min(1).max(100).required()
      .messages({
        'string.empty': 'El nombre de la organización no puede estar vacío',
        'string.min': 'El nombre debe tener al menos {#limit} caracteres',
        'string.max': 'El nombre no puede exceder {#limit} caracteres',
        'any.required': 'El nombre es requerido'
      }),
    userId: Joi.string().required()
      .messages({
        'string.base': 'El ID de usuario debe ser una cadena de texto',
        'any.required': 'El ID de usuario es obligatorio'
      }),
  }),
  
  updateOrg: Joi.object({
    name: Joi.string().trim().min(1).max(100).required()
      .messages({
        'string.empty': 'El nombre de la organización no puede estar vacío',
        'string.min': 'El nombre debe tener al menos {#limit} caracteres',
        'string.max': 'El nombre no puede exceder {#limit} caracteres',
        'any.required': 'El nombre es requerido'
      }),
  }),
  
  addMember: Joi.object({
    userId: commonSchemas.id.required()
      .messages({
        'any.required': 'El ID de usuario es requerido'
      }),
    role: commonSchemas.orgRole.default('VIEWER')
      .messages({
        'any.only': 'Rol inválido. Debe ser OWNER, ADMIN, VIEWER o NONE'
      }),
  }),
  
  updateMember: Joi.object({
    role: commonSchemas.orgRole.required()
      .messages({
        'any.required': 'El rol es requerido',
        'any.only': 'Rol inválido. Debe ser OWNER, ADMIN, VIEWER o NONE'
      }),
  })
};

// Endpoints (ya protegidos por la API key administrativa en routes/index.js)
router.get('/', organizationsController.getAllOrganizations);
router.get('/:id', validate({ params: schemas.idParam }), organizationsController.getOrganizationById);
router.post('/', validate({ body: schemas.createOrg }), organizationsController.createOrganization);

// Endpoints que requieren permisos específicos
router.put('/:id', 
  validate({ params: schemas.idParam, body: schemas.updateOrg }), 
  organizationsController.updateOrganization
);

// Endpoints para gestión de miembros
router.get('/:id/members', 
  validate({ params: schemas.idParam }), 
  organizationsController.getOrganizationMembers
);

router.post('/:id/members', 
  validate({ params: schemas.idParam, body: schemas.addMember }), 
  organizationsController.addOrganizationMember
);

router.put('/:orgId/members/:userId', 
  validate({ params: schemas.orgIdUserIdParams, body: schemas.updateMember }), 
  organizationsController.updateOrganizationMember
);

router.delete('/:orgId/members/:userId', 
  validate({ params: schemas.orgIdUserIdParams }), 
  organizationsController.removeOrganizationMember
);

module.exports = router;

================
File: src/routes/project-memberships.routes.js
================
'use strict';

const express = require('express');
const router = express.Router({ mergeParams: true }); // Para acceder a projectId de la ruta padre
const { validate, Joi, commonSchemas } = require('../middleware/validation.middleware');
const projectMembershipsController = require('../controllers/project-memberships.controller');

// Esquemas de validación
const schemas = {
  projectIdParam: Joi.object({
    projectId: commonSchemas.id.required()
      .messages({
        'any.required': 'El ID de proyecto es requerido'
      }),
  }),
  
  userIdParam: Joi.object({
    userId: commonSchemas.id.required()
      .messages({
        'any.required': 'El ID de usuario es requerido'
      }),
  }),
  
  addMember: Joi.object({
    userId: commonSchemas.id.required()
      .messages({
        'any.required': 'El ID de usuario es requerido'
      }),
    role: Joi.string().valid('OWNER', 'ADMIN', 'MEMBER', 'VIEWER').default('VIEWER')
      .messages({
        'any.only': 'Rol inválido. Debe ser OWNER, ADMIN, MEMBER o VIEWER'
      }),
  }),
  
  updateMember: Joi.object({
    role: Joi.string().valid('OWNER', 'ADMIN', 'MEMBER', 'VIEWER').required()
      .messages({
        'any.required': 'El rol es requerido',
        'any.only': 'Rol inválido. Debe ser OWNER, ADMIN, MEMBER o VIEWER'
      }),
  }),
  
  batchAddMembers: Joi.object({
    members: Joi.array().items(
      Joi.object({
        userId: commonSchemas.id.required()
          .messages({
            'any.required': 'El ID de usuario es requerido para cada miembro'
          }),
        role: Joi.string().valid('OWNER', 'ADMIN', 'MEMBER', 'VIEWER').default('VIEWER')
          .messages({
            'any.only': 'Rol inválido. Debe ser OWNER, ADMIN, MEMBER o VIEWER'
          }),
      })
    ).min(1).required()
      .messages({
        'array.min': 'Se requiere al menos un miembro',
        'any.required': 'El array de miembros es requerido'
      }),
  }),
};

// Obtener todos los miembros de un proyecto
router.get('/', 
  validate({ params: schemas.projectIdParam }), 
  projectMembershipsController.getProjectMembers
);

// Añadir un miembro a un proyecto
router.post('/', 
  validate({ params: schemas.projectIdParam, body: schemas.addMember }), 
  projectMembershipsController.addProjectMember
);

// Añadir múltiples miembros a un proyecto
router.post('/batch', 
  validate({ params: schemas.projectIdParam, body: schemas.batchAddMembers }), 
  projectMembershipsController.addBatchProjectMembers
);

// Obtener un miembro específico
router.get('/:userId', 
  validate({ params: Joi.object().keys({
    ...schemas.projectIdParam.keys,
    ...schemas.userIdParam.keys
  })}), 
  projectMembershipsController.getProjectMember
);

// Actualizar rol de un miembro
router.put('/:userId', 
  validate({ 
    params: Joi.object().keys({
      ...schemas.projectIdParam.keys,
      ...schemas.userIdParam.keys
    }),
    body: schemas.updateMember 
  }), 
  projectMembershipsController.updateProjectMember
);

// Eliminar un miembro
router.delete('/:userId', 
  validate({ params: Joi.object().keys({
    ...schemas.projectIdParam.keys,
    ...schemas.userIdParam.keys
  })}), 
  projectMembershipsController.removeProjectMember
);

module.exports = router;

================
File: src/routes/projects.routes.js
================
'use strict';

const express = require('express');
const router = express.Router();
const { validate, Joi, commonSchemas } = require('../middleware/validation.middleware');
const projectsController = require('../controllers/projects.controller');
const apiKeysController = require('../controllers/api-keys.controller');
const projectMembershipsRoutes = require('./project-memberships.routes');
const { NotFoundError } = require('../utils/errors');
const { db } = require('../services/database.service');

// Esquemas de validación
const schemas = {
  idParam: Joi.object({
    id: commonSchemas.id.required(),
  }),
  
  queryOrgId: Joi.object({
    orgId: Joi.string().optional()
      .messages({
        'string.base': 'El ID de organización debe ser una cadena de texto'
      }),
  }),
  
  createProject: Joi.object({
    name: Joi.string().trim().min(1).max(100).required()
      .messages({
        'string.empty': 'El nombre del proyecto no puede estar vacío',
        'string.min': 'El nombre debe tener al menos {#limit} caracteres',
        'string.max': 'El nombre no puede exceder {#limit} caracteres',
        'any.required': 'El nombre es requerido'
      }),
    orgId: commonSchemas.id.required()
      .messages({
        'any.required': 'El ID de organización es requerido'
      }),
  }),
  
  updateProject: Joi.object({
    name: Joi.string().trim().min(1).max(100).required()
      .messages({
        'string.empty': 'El nombre del proyecto no puede estar vacío',
        'string.min': 'El nombre debe tener al menos {#limit} caracteres',
        'string.max': 'El nombre no puede exceder {#limit} caracteres',
        'any.required': 'El nombre es requerido'
      }),
  }),
  
  createApiKey: Joi.object({
    note: Joi.string().trim().allow('').max(255).optional()
      .messages({
        'string.max': 'La nota no puede exceder {#limit} caracteres'
      }),
    expiresAt: Joi.date().iso().min('now').optional()
      .messages({
        'date.base': 'Fecha de expiración inválida',
        'date.min': 'La fecha de expiración debe ser futura'
      })
  }),
};

// Middleware para verificar que un proyecto existe
const checkProjectExists = async (req, res, next) => {
  try {
    const { id } = req.params;
    const project = await db.queryOne(
      'SELECT org_id FROM projects WHERE id = $1 AND deleted_at IS NULL',
      [id]
    );
    
    if (!project) {
      throw new NotFoundError('Proyecto');
    }
    
    next();
  } catch (error) {
    next(error);
  }
};

// Endpoints para proyectos
router.get('/', 
  validate({ query: schemas.queryOrgId }), 
  projectsController.getAllProjects
);

router.get('/:id', 
  validate({ params: schemas.idParam }), 
  projectsController.getProjectById
);

router.post('/', 
  validate({ body: schemas.createProject }), 
  projectsController.createProject
);

router.put('/:id', 
  validate({ params: schemas.idParam, body: schemas.updateProject }), 
  checkProjectExists,
  projectsController.updateProject
);

router.delete('/:id', 
  validate({ params: schemas.idParam }), 
  checkProjectExists,
  projectsController.deleteProject
);

// Rutas para API keys de proyectos
router.get('/:id/api-keys',
  validate({ params: schemas.idParam }),
  checkProjectExists,
  apiKeysController.getProjectApiKeys
);

router.post('/:id/api-keys',
  validate({ params: schemas.idParam, body: schemas.createApiKey }),
  checkProjectExists,
  apiKeysController.createApiKey
);

// Usar rutas de membresías de proyecto
router.use('/:projectId/members', projectMembershipsRoutes);

module.exports = router;

================
File: src/routes/users.routes.js
================
'use strict';

const express = require('express');
const router = express.Router();
const { validate, Joi, commonSchemas } = require('../middleware/validation.middleware');
const usersController = require('../controllers/users.controller');

// Esquemas de validación
const schemas = {
  listUsers: Joi.object({
    search: Joi.string().trim().max(50).optional(),
    limit: Joi.number().integer().min(1).max(100).default(10).optional(),
    page: Joi.number().integer().min(1).default(1).optional()
  }),
  
  idParam: Joi.object({
    id: commonSchemas.id.required()
      .messages({
        'any.required': 'El ID de usuario es requerido'
      }),
  }),
  
  createUser: Joi.object({
    name: Joi.string().trim().min(2).max(100).required()
      .messages({
        'string.empty': 'El nombre no puede estar vacío',
        'string.min': 'El nombre debe tener al menos {#limit} caracteres',
        'string.max': 'El nombre no puede exceder {#limit} caracteres',
        'any.required': 'El nombre es requerido'
      }),
    email: commonSchemas.email.required()
      .messages({
        'string.email': 'El email debe tener un formato válido',
        'any.required': 'El email es requerido'
      }),
    password: Joi.string().min(8).max(100).optional()
      .messages({
        'string.min': 'La contraseña debe tener al menos {#limit} caracteres',
        'string.max': 'La contraseña no puede exceder {#limit} caracteres'
      }),
    admin: Joi.boolean().optional()
  }),
  
  updateUser: Joi.object({
    name: Joi.string().trim().min(2).max(100).optional()
      .messages({
        'string.empty': 'El nombre no puede estar vacío',
        'string.min': 'El nombre debe tener al menos {#limit} caracteres',
        'string.max': 'El nombre no puede exceder {#limit} caracteres'
      }),
    email: commonSchemas.email.optional()
      .messages({
        'string.email': 'El email debe tener un formato válido'
      }),
    image: Joi.string().uri().optional()
      .messages({
        'string.uri': 'La URL de la imagen debe ser válida'
      }),
    feature_flags: Joi.array().items(Joi.string()).optional(),
    admin: Joi.boolean().optional()
  })
};

// Endpoint para listar usuarios con paginación y búsqueda
router.get('/', validate({ query: schemas.listUsers }), usersController.getUsers);

// Endpoint para obtener un usuario específico
router.get('/:id', validate({ params: schemas.idParam }), usersController.getUserById);

// Endpoint para crear un nuevo usuario
router.post('/', validate({ body: schemas.createUser }), usersController.createUser);

// Endpoint para actualizar un usuario
router.put('/:id', 
  validate({ params: schemas.idParam, body: schemas.updateUser }), 
  usersController.updateUser
);

// Endpoint para eliminar un usuario
router.delete('/:id', validate({ params: schemas.idParam }), usersController.deleteUser);

module.exports = router;

================
File: src/services/api-keys.service.js
================
'use strict';

const { db, transaction } = require('./database.service');
const { generateId, generateApiKey, hashSecretKey } = require('../utils/id-generator');
const { NotFoundError, BusinessLogicError } = require('../utils/errors');
const { createContextLogger } = require('../utils/logger');

// Logger contextual para este servicio
const logger = createContextLogger('api-keys-service');

/**
 * Servicio para manejar operaciones relacionadas con API keys
 */
class ApiKeysService {
  /**
   * Obtiene todas las API keys de un proyecto
   * @param {string} projectId - ID del proyecto
   * @returns {Promise<Array>} Lista de API keys
   */
  async getByProject(projectId) {
    return db.query(
      `SELECT id, created_at, public_key, display_secret_key, last_used_at, note, expires_at
       FROM api_keys
       WHERE project_id = $1
       ORDER BY created_at DESC`,
      [projectId]
    );
  }

  /**
   * Obtiene detalles de una API key específica
   * @param {string} id - ID de la API key
   * @returns {Promise<Object|null>} Detalles de la API key o null si no existe
   */
  async getById(id) {
    const apiKey = await db.queryOne(
      `SELECT ak.id, ak.created_at, ak.public_key, ak.display_secret_key, 
              ak.last_used_at, ak.note, ak.expires_at, p.id as project_id, p.name as project_name
       FROM api_keys ak
       JOIN projects p ON ak.project_id = p.id
       WHERE ak.id = $1 AND p.deleted_at IS NULL`,
      [id]
    );
    
    if (!apiKey) {
      throw new NotFoundError('API key');
    }
    
    return apiKey;
  }

  /**
   * Crea una nueva API key para un proyecto
   * @param {string} projectId - ID del proyecto
   * @param {Object} data - Datos adicionales
   * @param {string} data.note - Nota descriptiva (opcional)
   * @param {Date|string|null} data.expiresAt - Fecha de expiración (opcional)
   * @returns {Promise<Object>} Nueva API key creada
   */
  async create(projectId, { note = null, expiresAt = null } = {}) {
    // Validar fecha de expiración si se proporciona
    let parsedExpiresAt = null;
    if (expiresAt) {
      parsedExpiresAt = new Date(expiresAt);
      
      if (isNaN(parsedExpiresAt.getTime())) {
        throw new BusinessLogicError('Formato de fecha de expiración inválido');
      }
      
      // Verificar que la fecha sea futura
      if (parsedExpiresAt <= new Date()) {
        throw new BusinessLogicError('La fecha de expiración debe ser futura');
      }
    }
    
    return transaction(async (client) => {
      // Verificar si el proyecto existe
      const projectCheck = await client.query(
        'SELECT id FROM projects WHERE id = $1 AND deleted_at IS NULL',
        [projectId]
      );
      
      if (projectCheck.rows.length === 0) {
        throw new NotFoundError('Proyecto');
      }
      
      // Generar API keys
      const publicKey = generateApiKey('pk');
      const secretKey = generateApiKey('sk');
      const hashedSecretKey = hashSecretKey(secretKey);
      
      // Crear API key
      const apiKeyId = generateId('key');
      const apiKeyResult = await client.query(
        `INSERT INTO api_keys (
          id, 
          project_id, 
          created_at, 
          public_key, 
          hashed_secret_key, 
          display_secret_key,
          note,
          expires_at
        ) VALUES ($1, $2, CURRENT_TIMESTAMP, $3, $4, $5, $6, $7)
        RETURNING id, created_at, public_key, display_secret_key, note, expires_at`,
        [
          apiKeyId, 
          projectId, 
          publicKey, 
          hashedSecretKey, 
          secretKey.substring(0, 8) + '...', 
          note,
          parsedExpiresAt
        ]
      );
      
      logger.info(`Nueva API key creada con ID: ${apiKeyId} para proyecto ${projectId}${parsedExpiresAt ? ` (expira: ${parsedExpiresAt.toISOString()})` : ''}`);
      
      // Devolver con secretKey completa (solo se muestra una vez)
      return {
        ...apiKeyResult.rows[0],
        secretKey
      };
    });
  }

  /**
   * Regenera una API key existente
   * @param {string} id - ID de la API key
   * @param {Object} options - Opciones de regeneración
   * @param {Date|string|null} options.expiresAt - Nueva fecha de expiración (opcional)
   * @returns {Promise<Object>} Nueva API key regenerada
   */
  async regenerate(id, { expiresAt = null } = {}) {
    // Validar fecha de expiración si se proporciona
    let parsedExpiresAt = null;
    if (expiresAt) {
      parsedExpiresAt = new Date(expiresAt);
      
      if (isNaN(parsedExpiresAt.getTime())) {
        throw new BusinessLogicError('Formato de fecha de expiración inválido');
      }
      
      // Verificar que la fecha sea futura
      if (parsedExpiresAt <= new Date()) {
        throw new BusinessLogicError('La fecha de expiración debe ser futura');
      }
    }
    
    return transaction(async (client) => {
      // Verificar si la API key existe
      const apiKeyCheck = await client.query(
        'SELECT id, project_id, note, expires_at FROM api_keys WHERE id = $1',
        [id]
      );
      
      if (apiKeyCheck.rows.length === 0) {
        throw new NotFoundError('API key');
      }
      
      const existingKey = apiKeyCheck.rows[0];
      
      // Si no se proporciona nueva fecha de expiración, mantener la actual
      if (expiresAt === null && existingKey.expires_at) {
        parsedExpiresAt = existingKey.expires_at;
      }
      
      // Generar nuevas claves
      const publicKey = generateApiKey('pk');
      const secretKey = generateApiKey('sk');
      const hashedSecretKey = hashSecretKey(secretKey);
      
      // Actualizar la API key existente
      const apiKeyResult = await client.query(
        `UPDATE api_keys
         SET public_key = $1, 
             hashed_secret_key = $2, 
             display_secret_key = $3,
             updated_at = CURRENT_TIMESTAMP,
             expires_at = $4
         WHERE id = $5
         RETURNING id, created_at, public_key, display_secret_key, note, last_used_at, expires_at`,
        [
          publicKey,
          hashedSecretKey,
          secretKey.substring(0, 8) + '...',
          parsedExpiresAt,
          id
        ]
      );
      
      logger.info(`API key regenerada con ID: ${id}${parsedExpiresAt ? ` (expira: ${parsedExpiresAt.toISOString()})` : ''}`);
      
      // Devolver con secretKey completa (solo se muestra una vez)
      return {
        ...apiKeyResult.rows[0],
        secretKey
      };
    });
  }

  /**
   * Actualiza la fecha de expiración de una API key
   * @param {string} id - ID de la API key
   * @param {Date|string|null} expiresAt - Nueva fecha de expiración (null para eliminar expiración)
   * @returns {Promise<Object>} API key actualizada
   */
  async updateExpiration(id, expiresAt) {
    // Validar fecha de expiración si no es null
    let parsedExpiresAt = null;
    if (expiresAt) {
      parsedExpiresAt = new Date(expiresAt);
      
      if (isNaN(parsedExpiresAt.getTime())) {
        throw new BusinessLogicError('Formato de fecha de expiración inválido');
      }
      
      // Verificar que la fecha sea futura
      if (parsedExpiresAt <= new Date()) {
        throw new BusinessLogicError('La fecha de expiración debe ser futura');
      }
    }
    
    const result = await db.query(
      `UPDATE api_keys
       SET expires_at = $1, updated_at = CURRENT_TIMESTAMP
       WHERE id = $2
       RETURNING id, created_at, public_key, display_secret_key, note, last_used_at, expires_at`,
      [parsedExpiresAt, id]
    );
    
    if (result.length === 0) {
      throw new NotFoundError('API key');
    }
    
    logger.info(`Expiración de API key ${id} actualizada: ${parsedExpiresAt ? parsedExpiresAt.toISOString() : 'sin expiración'}`);
    return result[0];
  }

  /**
   * Actualiza la nota de una API key
   * @param {string} id - ID de la API key
   * @param {string} note - Nueva nota descriptiva
   * @returns {Promise<Object>} API key actualizada
   */
  async updateNote(id, note) {
    const result = await db.query(
      `UPDATE api_keys
       SET note = $1, updated_at = CURRENT_TIMESTAMP
       WHERE id = $2
       RETURNING id, created_at, public_key, display_secret_key, note, last_used_at, expires_at`,
      [note, id]
    );
    
    if (result.length === 0) {
      throw new NotFoundError('API key');
    }
    
    logger.info(`Nota de API key ${id} actualizada`);
    return result[0];
  }

  /**
   * Elimina una API key
   * @param {string} id - ID de la API key
   * @returns {Promise<boolean>} true si se eliminó correctamente
   */
  async delete(id) {
    const result = await db.query(
      'DELETE FROM api_keys WHERE id = $1 RETURNING id',
      [id]
    );
    
    if (result.length === 0) {
      throw new NotFoundError('API key');
    }
    
    logger.info(`API key eliminada: ${id}`);
    return true;
  }

  /**
   * Obtiene todas las API keys expiradas
   * @returns {Promise<Array>} Lista de API keys expiradas
   */
  async getExpired() {
    return db.query(
      `SELECT id, created_at, public_key, display_secret_key, last_used_at, note, expires_at, project_id
       FROM api_keys
       WHERE expires_at IS NOT NULL AND expires_at < CURRENT_TIMESTAMP
       ORDER BY expires_at ASC`
    );
  }

  /**
   * Elimina todas las API keys expiradas
   * @returns {Promise<number>} Número de API keys eliminadas
   */
  async cleanupExpired() {
    const result = await db.query(
      `DELETE FROM api_keys 
       WHERE expires_at IS NOT NULL AND expires_at < CURRENT_TIMESTAMP
       RETURNING id`
    );
    
    const count = result.length;
    if (count > 0) {
      logger.info(`Eliminadas ${count} API keys expiradas`);
    }
    
    return count;
  }

  /**
   * Verifica una API key para autenticación
   * @param {string} publicKey - Clave pública
   * @param {string} secretKey - Clave secreta
   * @returns {Promise<Object|null>} Proyecto asociado o null si las credenciales son inválidas
   */
  async verify(publicKey, secretKey) {
    if (!publicKey || !secretKey) {
      return null;
    }
    
    // Buscar la API key por su clave pública
    const apiKey = await db.queryOne(
      `SELECT project_id, hashed_secret_key, expires_at 
       FROM api_keys 
       WHERE public_key = $1`,
      [publicKey]
    );
    
    if (!apiKey) {
      return null;
    }
    
    // Verificar si la clave ha expirado
    if (apiKey.expires_at && new Date(apiKey.expires_at) < new Date()) {
      logger.warn(`Intento de uso de API key expirada: ${publicKey}`);
      return null;
    }
    
    // Verificar la clave secreta hasheada
    const hashedSecret = hashSecretKey(secretKey);
    
    if (hashedSecret !== apiKey.hashed_secret_key) {
      return null;
    }
    
    // Buscar el proyecto
    const project = await db.queryOne(
      'SELECT id, org_id, name, deleted_at FROM projects WHERE id = $1',
      [apiKey.project_id]
    );
    
    if (!project || project.deleted_at) {
      return null;
    }
    
    // Actualizar último uso de la API key
    await db.query(
      'UPDATE api_keys SET last_used_at = CURRENT_TIMESTAMP WHERE public_key = $1',
      [publicKey]
    );
    
    // Retornar proyecto (sin deleted_at)
    const { deleted_at, ...projectData } = project;
    return projectData;
  }
}

module.exports = new ApiKeysService();

================
File: src/services/database.service.js
================
'use strict';

const { Pool } = require('pg');
const config = require('../config');
const { DatabaseError } = require('../utils/errors');
const { logger } = require('../utils/logger');

/**
 * Abstracción de la base de datos para centralizar manejo de conexiones y queries
 */
class DatabaseService {
  constructor() {
    // Initialize the pool configuration
    const poolConfig = {
      host: config.db.host,
      port: config.db.port,
      database: config.db.database,
      user: config.db.user,
      password: config.db.password,
      max: config.db.pool.max,
      idleTimeoutMillis: config.db.pool.idleTimeoutMillis,
      connectionTimeoutMillis: config.db.pool.acquireTimeoutMillis,
    };

    // Configure SSL if enabled
    if (config.db.ssl) {
      poolConfig.ssl = typeof config.db.ssl === 'object' 
        ? config.db.ssl 
        : { rejectUnauthorized: false };
    }

    // Log connection details (excluding sensitive data)
    logger.info('Initializing database connection', {
      host: config.db.host,
      port: config.db.port,
      database: config.db.database,
      user: config.db.user,
      sslEnabled: !!config.db.ssl,
    });

    // Create the connection pool
    this.pool = new Pool(poolConfig);

    // Events for pool monitoring
    this.pool.on('connect', () => {
      logger.debug('Connection acquired from pool');
    });

    this.pool.on('error', (err) => {
      logger.error('Unexpected error in pool client', {
        error: err.message,
        stack: err.stack,
        code: err.code
      });
    });

    logger.info('Database service initialized');
  }

  /**
   * Ejecuta una consulta individual
   * @param {string} text - Consulta SQL
   * @param {Array} params - Parámetros para consulta
   * @returns {Promise<Object>} - Resultado de la consulta
   */
  async query(text, params = []) {
    try {
      const start = Date.now();
      const result = await this.pool.query(text, params);
      const duration = Date.now() - start;
      
      // Loguear consultas lentas
      if (duration > 500) {
        logger.warn(`Consulta lenta (${duration}ms): ${text}`);
      } else {
        logger.debug(`Consulta ejecutada (${duration}ms): ${text}`);
      }
      
      return result.rows;
    } catch (error) {
      logger.error('Error en consulta:', {
        query: text,
        params,
        error: error.message,
        stack: error.stack,
        code: error.code
      });
      
      throw new DatabaseError('Error al ejecutar consulta', { cause: error });
    }
  }

  /**
   * Ejecuta una consulta y devuelve un solo registro
   * @param {string} text - Consulta SQL
   * @param {Array} params - Parámetros para consulta
   * @returns {Promise<Object|null>} - Registro único o null
   */
  async queryOne(text, params = []) {
    const rows = await this.query(text, params);
    return rows.length > 0 ? rows[0] : null;
  }

  /**
   * Ejecuta una transacción con múltiples consultas
   * @param {Function} callback - Función que recibe cliente y ejecuta consultas
   * @returns {Promise<any>} - Resultado del callback
   */
  async transaction(callback) {
    const client = await this.pool.connect();
    
    try {
      await client.query('BEGIN');
      const result = await callback(client);
      await client.query('COMMIT');
      return result;
    } catch (error) {
      await client.query('ROLLBACK');
      logger.error('Error en transacción:', {
        error: error.message,
        stack: error.stack,
        code: error.code
      });
      throw new DatabaseError('Error al ejecutar transacción', { cause: error });
    } finally {
      client.release();
    }
  }

  /**
   * Verifica la conexión a la base de datos
   * @returns {Promise<Object>} - Resultado de la verificación
   */
  async checkConnection() {
    try {
      const result = await this.pool.query('SELECT NOW() as time');
      return {
        status: 'connected',
        time: result.rows[0].time
      };
    } catch (error) {
      logger.error('Database connection check failed:', {
        error: error.message,
        code: error.code,
        stack: error.stack
      });
      
      return {
        status: 'error',
        error: error.message,
        code: error.code
      };
    }
  }

  /**
   * Cierra todas las conexiones del pool
   */
  async close() {
    logger.info('Cerrando conexiones de base de datos');
    return this.pool.end();
  }
}

// Singleton para reutilizar en toda la aplicación
const dbService = new DatabaseService();

module.exports = {
  db: dbService,
  transaction: async (callback) => dbService.transaction(callback)
};

================
File: src/services/organizations.service.js
================
'use strict';

const { db, transaction } = require('./database.service');
const { generateId } = require('../utils/id-generator');
const { 
  NotFoundError, 
  ConflictError, 
  BusinessLogicError 
} = require('../utils/errors');
const { createContextLogger } = require('../utils/logger');

// Logger contextual para este servicio
const logger = createContextLogger('organizations-service');

/**
 * Servicio para manejar operaciones relacionadas con organizaciones
 */
class OrganizationsService {
  /**
   * Obtiene todas las organizaciones
   * @returns {Promise<Array>} Lista de organizaciones
   */
  async getAll() {
    return db.query(
      'SELECT * FROM organizations ORDER BY created_at DESC'
    );
  }

  /**
   * Obtiene una organización por su ID
   * @param {string} id - ID de la organización
   * @returns {Promise<Object|null>} Organización o null si no existe
   */
  async getById(id) {
    return db.queryOne(
      'SELECT * FROM organizations WHERE id = $1',
      [id]
    );
  }

  /**
   * Crea una nueva organización
   * @param {Object} data - Datos de la organización
   * @param {string} data.name - Nombre de la organización
   * @param {string} data.userId - ID del usuario que será propietario (obligatorio)
   * @returns {Promise<Object>} Nueva organización creada
   */
  async create({ name, userId }) {
    if (!name || !name.trim()) {
      throw new BusinessLogicError('El nombre es requerido');
    }
    
    if (!userId) {
      throw new BusinessLogicError('El ID de usuario es obligatorio para crear una organización');
    }
    
    return transaction(async (client) => {
      // Verificar si el usuario proporcionado existe
      const userExists = await client.query(
        'SELECT id FROM users WHERE id = $1',
        [userId]
      );
      
      if (userExists.rows.length === 0) {
        throw new NotFoundError('Usuario no encontrado');
      }
      
      // Generar ID único para la organización usando cuid
      const id = generateId('org');
      
      // Insertar organización
      const result = await client.query(
        `INSERT INTO organizations (id, name, created_at, updated_at)
         VALUES ($1, $2, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
         RETURNING *`,
        [id, name.trim()]
      );
      
      const organization = result.rows[0];
      
      // Crear membresía para el usuario (propietario de la organización)
      const membershipId = generateId('om');
      await client.query(
        `INSERT INTO organization_memberships (id, org_id, user_id, role, created_at, updated_at)
         VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)`,
        [membershipId, id, userId, 'OWNER']
      );
      
      logger.info(`Organización creada con ID: ${id}, propietario: ${userId}`);
      return organization;
    });
  }

  /**
   * Actualiza una organización existente
   * @param {string} id - ID de la organización
   * @param {Object} data - Datos a actualizar
   * @param {string} data.name - Nuevo nombre
   * @returns {Promise<Object|null>} Organización actualizada o null
   */
  async update(id, { name }) {
    if (!name || !name.trim()) {
      throw new BusinessLogicError('El nombre es requerido');
    }
    
    const result = await db.query(
      `UPDATE organizations 
       SET name = $1, updated_at = CURRENT_TIMESTAMP 
       WHERE id = $2 
       RETURNING *`,
      [name.trim(), id]
    );
    
    if (result.length === 0) {
      return null;
    }
    
    logger.info(`Organización actualizada: ${id}`);
    return result[0];
  }

  /**
   * Obtiene los miembros de una organización
   * @param {string} orgId - ID de la organización
   * @returns {Promise<Array>} Lista de miembros
   */
  async getMembers(orgId) {
    // Verificar si la organización existe
    const org = await this.getById(orgId);
    if (!org) {
      throw new NotFoundError('Organización');
    }
    
    return db.query(
      `SELECT om.id, om.user_id, om.role, om.created_at, om.updated_at,
              u.name, u.email, u.image
       FROM organization_memberships om
       JOIN users u ON om.user_id = u.id
       WHERE om.org_id = $1
       ORDER BY om.created_at DESC`,
      [orgId]
    );
  }

  /**
   * Añade un usuario a una organización
   * @param {string} orgId - ID de la organización
   * @param {string} userId - ID del usuario
   * @param {string} role - Rol del usuario (OWNER, ADMIN, VIEWER, NONE)
   * @returns {Promise<Object>} Membresía creada
   */
  async addMember(orgId, userId, role = 'VIEWER') {
    if (!userId) {
      throw new BusinessLogicError('El ID de usuario es requerido');
    }
    
    // Validar rol
    const validRoles = ['OWNER', 'ADMIN', 'VIEWER', 'NONE'];
    if (!validRoles.includes(role)) {
      throw new BusinessLogicError('Rol inválido. Debe ser OWNER, ADMIN, VIEWER o NONE');
    }
    
    return transaction(async (client) => {
      // Verificar si el usuario existe
      const userCheck = await client.query(
        'SELECT id FROM users WHERE id = $1',
        [userId]
      );
      
      if (userCheck.rows.length === 0) {
        throw new NotFoundError('Usuario');
      }
      
      // Verificar si la organización existe
      const orgCheck = await client.query(
        'SELECT id FROM organizations WHERE id = $1',
        [orgId]
      );
      
      if (orgCheck.rows.length === 0) {
        throw new NotFoundError('Organización');
      }
      
      // Verificar si ya es miembro
      const memberCheck = await client.query(
        'SELECT id FROM organization_memberships WHERE org_id = $1 AND user_id = $2',
        [orgId, userId]
      );
      
      if (memberCheck.rows.length > 0) {
        throw new ConflictError('El usuario ya es miembro de esta organización');
      }
      
      // Crear membresía
      const membershipId = generateId('om');
      const memberResult = await client.query(
        `INSERT INTO organization_memberships (id, org_id, user_id, role, created_at, updated_at)
         VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
         RETURNING *`,
        [membershipId, orgId, userId, role]
      );
      
      logger.info(`Usuario ${userId} añadido a organización ${orgId} con rol ${role}`);
      return memberResult.rows[0];
    });
  }

  /**
   * Actualiza el rol de un miembro en la organización
   * @param {string} orgId - ID de la organización
   * @param {string} userId - ID del usuario
   * @param {string} role - Nuevo rol
   * @returns {Promise<Object>} Membresía actualizada
   */
  async updateMember(orgId, userId, role) {
    if (!role) {
      throw new BusinessLogicError('El rol es requerido');
    }
    
    // Validar rol
    const validRoles = ['OWNER', 'ADMIN', 'VIEWER', 'NONE'];
    if (!validRoles.includes(role)) {
      throw new BusinessLogicError('Rol inválido. Debe ser OWNER, ADMIN, VIEWER o NONE');
    }
    
    // Si el nuevo rol no es OWNER, verificar que no sea el último propietario
    let result;
    if (role !== 'OWNER') {
      result = await transaction(async (client) => {
        // Comprobar si el usuario actual es OWNER
        const currentRole = await client.query(
          'SELECT role FROM organization_memberships WHERE org_id = $1 AND user_id = $2',
          [orgId, userId]
        );
        
        if (currentRole.rows.length === 0) {
          throw new NotFoundError('Membresía');
        }
        
        if (currentRole.rows[0].role === 'OWNER') {
          // Contar propietarios
          const ownersCount = await client.query(
            'SELECT COUNT(*) FROM organization_memberships WHERE org_id = $1 AND role = $2',
            [orgId, 'OWNER']
          );
          
          if (parseInt(ownersCount.rows[0].count) <= 1) {
            throw new BusinessLogicError('No se puede cambiar el rol del último propietario');
          }
        }
        
        // Actualizar rol
        const updateResult = await client.query(
          `UPDATE organization_memberships 
           SET role = $1, updated_at = CURRENT_TIMESTAMP 
           WHERE org_id = $2 AND user_id = $3 
           RETURNING *`,
          [role, orgId, userId]
        );
        
        if (updateResult.rows.length === 0) {
          throw new NotFoundError('Membresía');
        }
        
        logger.info(`Rol de usuario ${userId} en organización ${orgId} actualizado a ${role}`);
        return updateResult.rows[0];
      });
    } else {
      // Si el nuevo rol es OWNER, simplemente actualizar
      const rows = await db.query(
        `UPDATE organization_memberships 
         SET role = $1, updated_at = CURRENT_TIMESTAMP 
         WHERE org_id = $2 AND user_id = $3 
         RETURNING *`,
        [role, orgId, userId]
      );
      
      if (rows.length === 0) {
        throw new NotFoundError('Membresía');
      }
      
      logger.info(`Usuario ${userId} promovido a propietario en organización ${orgId}`);
      result = rows[0];
    }
    
    return result;
  }

  /**
   * Elimina un miembro de la organización
   * @param {string} orgId - ID de la organización
   * @param {string} userId - ID del usuario
   * @returns {Promise<boolean>} true si se eliminó correctamente
   */
  async removeMember(orgId, userId) {
    return transaction(async (client) => {
      // Verificar si es el último propietario
      const currentRole = await client.query(
        'SELECT role FROM organization_memberships WHERE org_id = $1 AND user_id = $2',
        [orgId, userId]
      );
      
      if (currentRole.rows.length === 0) {
        throw new NotFoundError('Membresía');
      }
      
      if (currentRole.rows[0].role === 'OWNER') {
        // Contar propietarios
        const ownersCount = await client.query(
          'SELECT COUNT(*) FROM organization_memberships WHERE org_id = $1 AND role = $2',
          [orgId, 'OWNER']
        );
        
        if (parseInt(ownersCount.rows[0].count) <= 1) {
          throw new BusinessLogicError('No se puede eliminar al último propietario');
        }
      }
      
      // Primero eliminar membresías de proyecto relacionadas
      await client.query(
        'DELETE FROM project_memberships WHERE org_membership_id IN (SELECT id FROM organization_memberships WHERE org_id = $1 AND user_id = $2)',
        [orgId, userId]
      );
      
      // Luego eliminar la membresía de organización
      const deleteResult = await client.query(
        'DELETE FROM organization_memberships WHERE org_id = $1 AND user_id = $2 RETURNING *',
        [orgId, userId]
      );
      
      if (deleteResult.rows.length === 0) {
        throw new NotFoundError('Membresía');
      }
      
      logger.info(`Usuario ${userId} eliminado de organización ${orgId}`);
      return true;
    });
  }
}

module.exports = new OrganizationsService();

================
File: src/services/project-memberships.service.js
================
'use strict';

const { db, transaction } = require('./database.service');
const { generateId } = require('../utils/id-generator');
const { 
  NotFoundError, 
  ConflictError, 
  BusinessLogicError 
} = require('../utils/errors');
const { createContextLogger } = require('../utils/logger');

// Logger contextual para este servicio
const logger = createContextLogger('project-memberships-service');

/**
 * Servicio para manejar operaciones relacionadas con membresías de proyectos
 */
class ProjectMembershipsService {
  /**
   * Obtiene todos los miembros de un proyecto
   * @param {string} projectId - ID del proyecto
   * @returns {Promise<Array>} Lista de miembros
   */
  async getByProject(projectId) {
    // Verificar si el proyecto existe
    const projectExists = await db.queryOne(
      'SELECT id FROM projects WHERE id = $1 AND deleted_at IS NULL',
      [projectId]
    );
    
    if (!projectExists) {
      throw new NotFoundError('Proyecto');
    }
    
    return db.query(
      `SELECT pm.project_id, pm.user_id, pm.role, pm.created_at, pm.updated_at,
              u.name, u.email, u.image
       FROM project_memberships pm
       JOIN users u ON pm.user_id = u.id
       WHERE pm.project_id = $1
       ORDER BY pm.created_at DESC`,
      [projectId]
    );
  }

  /**
   * Obtiene detalles de un miembro específico
   * @param {string} projectId - ID del proyecto
   * @param {string} userId - ID del usuario
   * @returns {Promise<Object|null>} Detalles de la membresía
   */
  async getMember(projectId, userId) {
    return db.queryOne(
      `SELECT pm.project_id, pm.user_id, pm.role, pm.created_at, pm.updated_at,
              u.name, u.email, u.image
       FROM project_memberships pm
       JOIN users u ON pm.user_id = u.id
       WHERE pm.project_id = $1 AND pm.user_id = $2`,
      [projectId, userId]
    );
  }

  /**
   * Añade un usuario a un proyecto
   * @param {string} projectId - ID del proyecto
   * @param {string} userId - ID del usuario
   * @param {string} role - Rol del usuario (OWNER, ADMIN, MEMBER, VIEWER)
   * @returns {Promise<Object>} Membresía creada
   */
  async addMember(projectId, userId, role = 'VIEWER') {
    if (!userId) {
      throw new BusinessLogicError('El ID de usuario es requerido');
    }
    
    // Validar rol
    const validRoles = ['OWNER', 'ADMIN', 'MEMBER', 'VIEWER'];
    if (!validRoles.includes(role)) {
      throw new BusinessLogicError('Rol inválido. Debe ser OWNER, ADMIN, MEMBER o VIEWER');
    }
    
    return transaction(async (client) => {
      // Verificar si el proyecto existe
      const projectCheck = await client.query(
        'SELECT id, org_id FROM projects WHERE id = $1 AND deleted_at IS NULL',
        [projectId]
      );
      
      if (projectCheck.rows.length === 0) {
        throw new NotFoundError('Proyecto');
      }
      
      const orgId = projectCheck.rows[0].org_id;
      
      // Verificar si el usuario existe
      const userCheck = await client.query(
        'SELECT id FROM users WHERE id = $1',
        [userId]
      );
      
      if (userCheck.rows.length === 0) {
        throw new NotFoundError('Usuario');
      }
      
      // Verificar si existe membresía de organización
      const orgMembershipCheck = await client.query(
        'SELECT id FROM organization_memberships WHERE org_id = $1 AND user_id = $2',
        [orgId, userId]
      );
      
      let orgMembershipId;
      
      if (orgMembershipCheck.rows.length === 0) {
        // Crear membresía de organización primero con rol VIEWER por defecto
        orgMembershipId = generateId('om');
        await client.query(
          `INSERT INTO organization_memberships (id, org_id, user_id, role, created_at, updated_at)
           VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)`,
          [orgMembershipId, orgId, userId, 'VIEWER']
        );
        
        logger.info(`Usuario ${userId} añadido a organización ${orgId} automáticamente`);
      } else {
        orgMembershipId = orgMembershipCheck.rows[0].id;
      }
      
      // Verificar si ya es miembro del proyecto
      const memberCheck = await client.query(
        'SELECT project_id, user_id FROM project_memberships WHERE project_id = $1 AND user_id = $2',
        [projectId, userId]
      );
      
      if (memberCheck.rows.length > 0) {
        throw new ConflictError('El usuario ya es miembro de este proyecto');
      }
      
      // Crear membresía de proyecto
      const memberResult = await client.query(
        `INSERT INTO project_memberships (project_id, user_id, org_membership_id, role, created_at, updated_at)
         VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
         RETURNING project_id, user_id, role, created_at, updated_at`,
        [projectId, userId, orgMembershipId, role]
      );
      
      // Obtener datos del usuario para devolver información completa
      const userResult = await client.query(
        'SELECT name, email, image FROM users WHERE id = $1',
        [userId]
      );
      
      logger.info(`Usuario ${userId} añadido a proyecto ${projectId} con rol ${role}`);
      
      return {
        ...memberResult.rows[0],
        ...userResult.rows[0]
      };
    });
  }

  /**
   * Actualiza el rol de un miembro en el proyecto
   * @param {string} projectId - ID del proyecto
   * @param {string} userId - ID del usuario
   * @param {string} role - Nuevo rol
   * @returns {Promise<Object>} Membresía actualizada
   */
  async updateMember(projectId, userId, role) {
    if (!role) {
      throw new BusinessLogicError('El rol es requerido');
    }
    
    // Validar rol
    const validRoles = ['OWNER', 'ADMIN', 'MEMBER', 'VIEWER'];
    if (!validRoles.includes(role)) {
      throw new BusinessLogicError('Rol inválido. Debe ser OWNER, ADMIN, MEMBER o VIEWER');
    }
    
    // Si el nuevo rol no es OWNER, verificar que no sea el último propietario
    let result;
    if (role !== 'OWNER') {
      result = await transaction(async (client) => {
        // Comprobar si el usuario actual es OWNER
        const currentRole = await client.query(
          'SELECT role FROM project_memberships WHERE project_id = $1 AND user_id = $2',
          [projectId, userId]
        );
        
        if (currentRole.rows.length === 0) {
          throw new NotFoundError('Membresía de proyecto');
        }
        
        if (currentRole.rows[0].role === 'OWNER') {
          // Contar propietarios
          const ownersCount = await client.query(
            'SELECT COUNT(*) FROM project_memberships WHERE project_id = $1 AND role = $2',
            [projectId, 'OWNER']
          );
          
          if (parseInt(ownersCount.rows[0].count) <= 1) {
            throw new BusinessLogicError('No se puede cambiar el rol del último propietario');
          }
        }
        
        // Actualizar rol
        const updateResult = await client.query(
          `UPDATE project_memberships 
           SET role = $1, updated_at = CURRENT_TIMESTAMP 
           WHERE project_id = $2 AND user_id = $3 
           RETURNING project_id, user_id, role, created_at, updated_at`,
          [role, projectId, userId]
        );
        
        if (updateResult.rows.length === 0) {
          throw new NotFoundError('Membresía de proyecto');
        }
        
        // Obtener datos del usuario para devolver información completa
        const userResult = await client.query(
          'SELECT name, email, image FROM users WHERE id = $1',
          [userId]
        );
        
        logger.info(`Rol de usuario ${userId} en proyecto ${projectId} actualizado a ${role}`);
        
        return {
          ...updateResult.rows[0],
          ...userResult.rows[0]
        };
      });
    } else {
      // Si el nuevo rol es OWNER, simplemente actualizar
      result = await transaction(async (client) => {
        const updateResult = await client.query(
          `UPDATE project_memberships 
           SET role = $1, updated_at = CURRENT_TIMESTAMP 
           WHERE project_id = $2 AND user_id = $3 
           RETURNING project_id, user_id, role, created_at, updated_at`,
          [role, projectId, userId]
        );
        
        if (updateResult.rows.length === 0) {
          throw new NotFoundError('Membresía de proyecto');
        }
        
        // Obtener datos del usuario para devolver información completa
        const userResult = await client.query(
          'SELECT name, email, image FROM users WHERE id = $1',
          [userId]
        );
        
        logger.info(`Usuario ${userId} promovido a propietario en proyecto ${projectId}`);
        
        return {
          ...updateResult.rows[0],
          ...userResult.rows[0]
        };
      });
    }
    
    return result;
  }

  /**
   * Elimina un miembro del proyecto
   * @param {string} projectId - ID del proyecto
   * @param {string} userId - ID del usuario
   * @returns {Promise<boolean>} true si se eliminó correctamente
   */
  async removeMember(projectId, userId) {
    return transaction(async (client) => {
      // Verificar si es el último propietario
      const currentRole = await client.query(
        'SELECT role FROM project_memberships WHERE project_id = $1 AND user_id = $2',
        [projectId, userId]
      );
      
      if (currentRole.rows.length === 0) {
        throw new NotFoundError('Membresía de proyecto');
      }
      
      if (currentRole.rows[0].role === 'OWNER') {
        // Contar propietarios
        const ownersCount = await client.query(
          'SELECT COUNT(*) FROM project_memberships WHERE project_id = $1 AND role = $2',
          [projectId, 'OWNER']
        );
        
        if (parseInt(ownersCount.rows[0].count) <= 1) {
          throw new BusinessLogicError('No se puede eliminar al último propietario');
        }
      }
      
      // Eliminar la membresía
      const deleteResult = await client.query(
        'DELETE FROM project_memberships WHERE project_id = $1 AND user_id = $2 RETURNING project_id',
        [projectId, userId]
      );
      
      if (deleteResult.rows.length === 0) {
        throw new NotFoundError('Membresía de proyecto');
      }
      
      logger.info(`Usuario ${userId} eliminado del proyecto ${projectId}`);
      return true;
    });
  }

  /**
   * Añade múltiples miembros a un proyecto
   * @param {string} projectId - ID del proyecto
   * @param {Array} members - Array de {userId, role}
   * @returns {Promise<Object>} Resultado con éxitos y errores
   */
  async addBatchMembers(projectId, members) {
    if (!Array.isArray(members) || members.length === 0) {
      throw new BusinessLogicError('Se requiere un array de miembros válido');
    }
    
    const result = {
      success: [],
      errors: []
    };
    
    // Verificar que el proyecto exista
    const projectExists = await db.queryOne(
      'SELECT id FROM projects WHERE id = $1 AND deleted_at IS NULL',
      [projectId]
    );
    
    if (!projectExists) {
      throw new NotFoundError('Proyecto');
    }
    
    // Procesar cada miembro secuencialmente para mejor manejo de errores
    for (const member of members) {
      try {
        const { userId, role = 'VIEWER' } = member;
        
        if (!userId) {
          result.errors.push({
            userId: member.userId || 'unknown',
            error: 'ID de usuario requerido'
          });
          continue;
        }
        
        const membership = await this.addMember(projectId, userId, role);
        result.success.push(membership);
      } catch (error) {
        logger.warn(`Error al añadir miembro ${member.userId} al proyecto ${projectId}:`, error);
        
        result.errors.push({
          userId: member.userId || 'unknown',
          error: error.message
        });
      }
    }
    
    return result;
  }
}

module.exports = new ProjectMembershipsService();

================
File: src/services/projects.service.js
================
'use strict';

const { db, transaction } = require('./database.service');
const { generateId, generateApiKey, hashSecretKey } = require('../utils/id-generator');
const { NotFoundError, BusinessLogicError } = require('../utils/errors');
const { createContextLogger } = require('../utils/logger');

// Logger contextual para este servicio
const logger = createContextLogger('projects-service');

/**
 * Servicio para manejar operaciones relacionadas con proyectos
 */
class ProjectsService {
  /**
   * Obtiene todos los proyectos
   * @param {string} orgId - ID de organización para filtrar (opcional)
   * @returns {Promise<Array>} Lista de proyectos
   */
  async getAll(orgId = null) {
    let queryText = 'SELECT * FROM projects WHERE deleted_at IS NULL';
    const params = [];
    
    if (orgId) {
      queryText += ' AND org_id = $1';
      params.push(orgId);
    }
    
    queryText += ' ORDER BY created_at DESC';
    
    return db.query(queryText, params);
  }

  /**
   * Obtiene un proyecto por su ID
   * @param {string} id - ID del proyecto
   * @returns {Promise<Object|null>} Proyecto o null si no existe
   */
  async getById(id) {
    return db.queryOne(
      'SELECT * FROM projects WHERE id = $1 AND deleted_at IS NULL',
      [id]
    );
  }

  /**
   * Crea un nuevo proyecto
   * @param {Object} data - Datos del proyecto
   * @param {string} data.name - Nombre del proyecto
   * @param {string} data.orgId - ID de la organización
   * @returns {Promise<Object>} Nuevo proyecto creado con API keys
   */
  async create({ name, orgId }) {
    if (!name || !name.trim()) {
      throw new BusinessLogicError('El nombre es requerido');
    }
    
    if (!orgId) {
      throw new BusinessLogicError('El ID de organización es requerido');
    }
    
    return transaction(async (client) => {
      // Verificar si la organización existe
      const orgCheck = await client.query(
        'SELECT id FROM organizations WHERE id = $1',
        [orgId]
      );
      
      if (orgCheck.rows.length === 0) {
        throw new NotFoundError('Organización');
      }
      
      // Generar ID único para el proyecto
      const projectId = generateId('prj');
      
      // Insertar proyecto
      const projectResult = await client.query(
        `INSERT INTO projects (id, name, org_id, created_at, updated_at)
         VALUES ($1, $2, $3, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
         RETURNING *`,
        [projectId, name.trim(), orgId]
      );
      
      const project = projectResult.rows[0];
      
      // Generar par de API keys
      const publicKey = generateApiKey('pk');
      const secretKey = generateApiKey('sk');
      const hashedSecretKey = hashSecretKey(secretKey);
      
      // Crear API key en la base de datos
      const apiKeyId = generateId('key');
      await client.query(
        `INSERT INTO api_keys (
          id, 
          project_id, 
          created_at, 
          public_key, 
          hashed_secret_key, 
          display_secret_key
        ) VALUES ($1, $2, CURRENT_TIMESTAMP, $3, $4, $5)`,
        [
          apiKeyId, 
          projectId, 
          publicKey, 
          hashedSecretKey, 
          secretKey.substring(0, 8) + '...'
        ]
      );
      
      logger.info(`Proyecto creado con ID: ${projectId} en organización ${orgId}`);
      
      // Devolver proyecto con API keys (secretKey solo se muestra una vez)
      return {
        ...project,
        apiKeys: {
          publicKey,
          secretKey // Completa, solo se muestra ahora
        }
      };
    });
  }

  /**
   * Actualiza un proyecto existente
   * @param {string} id - ID del proyecto
   * @param {Object} data - Datos a actualizar
   * @param {string} data.name - Nuevo nombre
   * @returns {Promise<Object|null>} Proyecto actualizado o null
   */
  async update(id, { name }) {
    if (!name || !name.trim()) {
      throw new BusinessLogicError('El nombre es requerido');
    }
    
    const result = await db.query(
      `UPDATE projects 
       SET name = $1, updated_at = CURRENT_TIMESTAMP 
       WHERE id = $2 AND deleted_at IS NULL
       RETURNING *`,
      [name.trim(), id]
    );
    
    if (result.length === 0) {
      return null;
    }
    
    logger.info(`Proyecto actualizado: ${id}`);
    return result[0];
  }

  /**
   * Marca un proyecto como eliminado (soft delete)
   * @param {string} id - ID del proyecto
   * @returns {Promise<boolean>} true si se eliminó correctamente
   */
  async delete(id) {
    const result = await db.query(
      `UPDATE projects 
       SET deleted_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP 
       WHERE id = $1 AND deleted_at IS NULL
       RETURNING id`,
      [id]
    );
    
    if (result.length === 0) {
      throw new NotFoundError('Proyecto');
    }
    
    logger.info(`Proyecto marcado como eliminado: ${id}`);
    return true;
  }
}

module.exports = new ProjectsService();

================
File: src/services/users.service.js
================
'use strict';

const { db, transaction } = require('./database.service');
const { generateId } = require('../utils/id-generator');
const { NotFoundError, ConflictError, BusinessLogicError } = require('../utils/errors');
const { createContextLogger } = require('../utils/logger');
const crypto = require('crypto');

// Logger contextual para este servicio
const logger = createContextLogger('users-service');

/**
 * Servicio para manejar operaciones relacionadas con usuarios
 */
class UsersService {
  /**
   * Obtiene todos los usuarios con paginación y búsqueda
   * @param {Object} options - Opciones de filtrado
   * @param {string} options.search - Término de búsqueda para nombre o email
   * @param {number} options.limit - Límite de resultados por página
   * @param {number} options.page - Número de página
   * @returns {Promise<Array>} Lista de usuarios
   */
  async getAll({ search, limit = 10, page = 1 }) {
    const offset = (page - 1) * limit;
    let queryText = `
      SELECT id, name, email, image, created_at, admin, 
             feature_flags, email_verified
      FROM users
    `;
    const params = [];
    
    if (search) {
      queryText += ` WHERE name ILIKE $1 OR email ILIKE $1`;
      params.push(`%${search}%`);
    }
    
    queryText += ` ORDER BY name LIMIT $${params.length + 1} OFFSET $${params.length + 2}`;
    params.push(parseInt(limit, 10), offset);
    
    const users = await db.query(queryText, params);
    
    // Obtener conteo total para paginación
    let countQuery = 'SELECT COUNT(*) FROM users';
    if (search) {
      countQuery += ` WHERE name ILIKE $1 OR email ILIKE $1`;
    }
    
    const totalCount = await db.queryOne(countQuery, search ? [`%${search}%`] : []);
    
    return {
      users,
      pagination: {
        total: parseInt(totalCount.count, 10),
        page: parseInt(page, 10),
        limit: parseInt(limit, 10),
        pages: Math.ceil(parseInt(totalCount.count, 10) / limit)
      }
    };
  }

  /**
   * Obtiene un usuario por su ID
   * @param {string} id - ID del usuario
   * @returns {Promise<Object|null>} Usuario o null si no existe
   */
  async getById(id) {
    const user = await db.queryOne(
      `SELECT id, name, email, image, created_at, updated_at, 
              admin, feature_flags, email_verified
       FROM users 
       WHERE id = $1`,
      [id]
    );
    
    return user;
  }

  /**
   * Crea un nuevo usuario
   * @param {Object} data - Datos del usuario
   * @param {string} data.name - Nombre
   * @param {string} data.email - Email
   * @param {string} data.password - Contraseña (opcional)
   * @returns {Promise<Object>} Usuario creado
   */
  async create({ name, email, password = null }) {
    if (!email) {
      throw new BusinessLogicError('El email es requerido');
    }
    
    return transaction(async (client) => {
      // Verificar si el email ya está en uso
      const existingUser = await client.query(
        'SELECT id FROM users WHERE email = $1',
        [email]
      );
      
      if (existingUser.rows.length > 0) {
        throw new ConflictError('El email ya está en uso');
      }
      
      // Hashear contraseña si se proporciona
      let hashedPassword = null;
      if (password) {
        // En producción, usar bcrypt o similar
        hashedPassword = crypto.createHash('sha256').update(password).digest('hex');
      }
      
      // Generar ID único
      const id = generateId('usr');
      
      // Insertar usuario
      const result = await client.query(
        `INSERT INTO users (
          id, name, email, password, created_at, updated_at
        ) VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
        RETURNING id, name, email, created_at, updated_at`,
        [id, name, email, hashedPassword]
      );
      
      logger.info(`Usuario creado con ID: ${id}`);
      return result.rows[0];
    });
  }

  /**
   * Actualiza un usuario existente
   * @param {string} id - ID del usuario
   * @param {Object} data - Datos a actualizar
   * @returns {Promise<Object|null>} Usuario actualizado o null
   */
  async update(id, { name, email, image, feature_flags, admin = false }) {
    const updateFields = [];
    const params = [id];
    let paramIndex = 2;
    
    // Construir query dinámicamente según los campos proporcionados
    if (name !== undefined) {
      updateFields.push(`name = $${paramIndex++}`);
      params.push(name);
    }
    
    if (email !== undefined) {
      updateFields.push(`email = $${paramIndex++}`);
      params.push(email);
    }
    
    if (image !== undefined) {
      updateFields.push(`image = $${paramIndex++}`);
      params.push(image);
    }
    
    if (feature_flags !== undefined) {
      updateFields.push(`feature_flags = $${paramIndex++}`);
      params.push(Array.isArray(feature_flags) ? feature_flags : []);
    }
    
    if (admin !== undefined) {
      updateFields.push(`admin = $${paramIndex++}`);
      params.push(Boolean(admin));
    }
    
    // Siempre actualizar el timestamp
    updateFields.push('updated_at = CURRENT_TIMESTAMP');
    
    if (updateFields.length === 1) {
      // Solo se actualizó el timestamp
      throw new BusinessLogicError('No hay campos para actualizar');
    }
    
    const query = `
      UPDATE users 
      SET ${updateFields.join(', ')} 
      WHERE id = $1 
      RETURNING id, name, email, image, created_at, updated_at, admin, feature_flags
    `;
    
    const result = await db.query(query, params);
    
    if (result.length === 0) {
      return null;
    }
    
    logger.info(`Usuario actualizado: ${id}`);
    return result[0];
  }

  /**
   * Elimina un usuario verificando dependencias
   * @param {string} id - ID del usuario
   * @returns {Promise<boolean>} true si se eliminó correctamente
   */
  async delete(id) {
    return transaction(async (client) => {
      // Verificar si tiene membresías de organización
      const memberships = await client.query(
        'SELECT COUNT(*) FROM organization_memberships WHERE user_id = $1',
        [id]
      );
      
      const membershipCount = parseInt(memberships.rows[0].count, 10);
      
      if (membershipCount > 0) {
        throw new BusinessLogicError(
          `No se puede eliminar el usuario porque pertenece a ${membershipCount} organización(es). ` +
          'Elimine primero las membresías del usuario.'
        );
      }
      
      // Eliminar cuentas vinculadas y sesiones
      await client.query('DELETE FROM "Account" WHERE user_id = $1', [id]);
      await client.query('DELETE FROM "Session" WHERE user_id = $1', [id]);
      
      // Finalmente eliminar el usuario
      const result = await client.query(
        'DELETE FROM users WHERE id = $1 RETURNING id',
        [id]
      );
      
      if (result.rows.length === 0) {
        throw new NotFoundError('Usuario');
      }
      
      logger.info(`Usuario eliminado: ${id}`);
      return true;
    });
  }
}

module.exports = new UsersService();

================
File: src/utils/config-checker.js
================
'use strict';

const { logger } = require('./logger');

/**
 * Utility to validate configuration settings
 */
class ConfigChecker {
  /**
   * Validates database configuration parameters and logs useful information
   * @param {Object} dbConfig - Database configuration object
   * @returns {Object} - Validation result with warnings and errors
   */
  static validateDatabaseConfig(dbConfig) {
    const result = {
      valid: true,
      warnings: [],
      errors: []
    };

    // Check for essential parameters
    if (!dbConfig.host) {
      result.errors.push('DB_HOST not defined');
      result.valid = false;
    }

    if (!dbConfig.port) {
      result.warnings.push('DB_PORT not defined, using default (5432)');
    } else if (isNaN(dbConfig.port)) {
      result.errors.push('DB_PORT must be a number');
      result.valid = false;
    }

    if (!dbConfig.database) {
      result.errors.push('DB_NAME not defined');
      result.valid = false;
    }

    if (!dbConfig.user) {
      result.errors.push('DB_USER not defined');
      result.valid = false;
    }

    if (!dbConfig.password) {
      result.warnings.push('DB_PASS not defined, make sure this is intentional');
    }

    // Additional validations
    if (dbConfig.host === 'localhost' && process.env.NODE_ENV === 'production') {
      result.warnings.push('Using localhost in production environment, ensure this is intentional');
    }

    // Log validation results
    if (result.warnings.length > 0) {
      logger.warn('Database configuration warnings:', { warnings: result.warnings });
    }

    if (result.errors.length > 0) {
      logger.error('Database configuration errors:', { errors: result.errors });
    } else {
      logger.info('Database configuration validated successfully');
    }

    return result;
  }

  /**
   * Validates the application configuration and logs useful diagnostic information
   * @param {Object} config - The application configuration object
   * @returns {boolean} - Whether the configuration is valid
   */
  static validateAppConfig(config) {
    logger.info('Application configuration:', {
      environment: config.nodeEnv,
      port: config.port,
      host: config.host,
      apiKeyAuthEnabled: config.enableApiKeyAuth,
      corsOrigin: config.corsOrigin,
      logLevel: config.logLevel
    });

    // Validate database configuration
    const dbValidation = this.validateDatabaseConfig(config.db);
    
    return dbValidation.valid;
  }

  /**
   * Format database connection string for logging (hiding sensitive data)
   * @param {Object} dbConfig - Database configuration object
   * @returns {string} - Formatted connection string for logging
   */
  static formatDbConnectionString(dbConfig) {
    return `postgres://${dbConfig.user}:***@${dbConfig.host}:${dbConfig.port}/${dbConfig.database}${dbConfig.ssl ? ' (SSL enabled)' : ''}`;
  }
}

module.exports = ConfigChecker;

================
File: src/utils/errors.js
================
'use strict';

/**
 * Sistema de errores personalizado para la aplicación
 * Permite categorizar y manejar errores de forma consistente
 */

/**
 * Error base de la aplicación
 * Todos los errores personalizados extenderán de esta clase
 */
class AppError extends Error {
  constructor(message, options = {}) {
    super(message);
    this.name = this.constructor.name;
    this.status = options.status || 500;
    this.code = options.code || 'INTERNAL_ERROR';
    this.cause = options.cause;
    this.details = options.details || {};
    
    // Capturar stack trace correctamente
    Error.captureStackTrace(this, this.constructor);
  }
  
  /**
   * Convierte el error a formato JSON para respuestas API
   */
  toJSON() {
    const error = {
      error: this.code,
      message: this.message,
    };
    
    // Incluir detalles si existen
    if (Object.keys(this.details).length > 0) {
      error.details = this.details;
    }
    
    return error;
  }
}

/**
 * Error de validación (400 Bad Request)
 */
class ValidationError extends AppError {
  constructor(message, details = {}) {
    super(message, {
      status: 400,
      code: 'VALIDATION_ERROR',
      details
    });
  }
}

/**
 * Error de autenticación (401 Unauthorized)
 */
class AuthenticationError extends AppError {
  constructor(message = 'Credenciales inválidas') {
    super(message, {
      status: 401,
      code: 'AUTHENTICATION_ERROR'
    });
  }
}

/**
 * Error de autorización (403 Forbidden)
 */
class AuthorizationError extends AppError {
  constructor(message = 'No tiene permisos para esta acción') {
    super(message, {
      status: 403,
      code: 'AUTHORIZATION_ERROR'
    });
  }
}

/**
 * Error de recurso no encontrado (404 Not Found)
 */
class NotFoundError extends AppError {
  constructor(resource = 'Recurso') {
    super(`${resource} no encontrado`, {
      status: 404,
      code: 'NOT_FOUND',
      details: { resource }
    });
  }
}

/**
 * Error de conflicto (409 Conflict)
 */
class ConflictError extends AppError {
  constructor(message, details = {}) {
    super(message, {
      status: 409,
      code: 'CONFLICT',
      details
    });
  }
}

/**
 * Error de base de datos
 */
class DatabaseError extends AppError {
  constructor(message = 'Error de base de datos', options = {}) {
    super(message, {
      ...options,
      status: options.status || 500,
      code: options.code || 'DATABASE_ERROR'
    });
  }
}

/**
 * Errores específicos de negocio
 */
class BusinessLogicError extends AppError {
  constructor(message, options = {}) {
    super(message, {
      ...options,
      status: options.status || 400,
      code: options.code || 'BUSINESS_LOGIC_ERROR'
    });
  }
}

module.exports = {
  AppError,
  ValidationError,
  AuthenticationError,
  AuthorizationError,
  NotFoundError,
  ConflictError,
  DatabaseError,
  BusinessLogicError
};

================
File: src/utils/id-generator.js
================
'use strict';

const crypto = require('crypto');
const { customAlphabet } = require('nanoid');
const cuid = require('cuid'); // Añadir dependencia a cuid

// Alfabeto seguro para IDs (evitando caracteres similares)
const ALPHABET = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';

// Crear generador de IDs con nanoid para mejor rendimiento y seguridad
const nanoid = customAlphabet(ALPHABET, 10);

/**
 * Genera un ID único compatible con el formato de Langfuse
 * @param {string} prefix - Prefijo para el ID según el tipo de entidad
 * @returns {string} - ID único en formato compatible con Langfuse
 */
function generateId(prefix = '') {
  // Para organizaciones y proyectos, usamos el formato de cuid que usa Langfuse
  if (prefix === 'org' || prefix === 'prj') {
    return cuid();
  }
  
  // Para otros tipos de entidades, seguimos usando el formato anterior
  const timestamp = Date.now().toString(36);
  const randomStr = nanoid();
  return `${prefix}_${timestamp}${randomStr}`;
}

/**
 * Genera un API key con el formato requerido
 * @param {string} prefix - Prefijo para la key (pk para pública, sk para secreta)
 * @returns {string} - API key formateada
 */
function generateApiKey(prefix) {
  // 32 bytes = 256 bits de entropía (muy seguro)
  const randomBytes = crypto.randomBytes(16).toString('hex');
  return `${prefix}_${randomBytes}`;
}

/**
 * Genera un hash seguro para almacenar la clave secreta
 * Usa un salt fijo "salt" para compatibilidad con Langfuse
 * @param {string} secretKey - Clave secreta a hashear
 * @returns {string} - Hash SHA-256 hexadecimal
 */
function hashSecretKey(secretKey) {
  const salt = "salt"; // Salt fijo usado por Langfuse
  return crypto.createHash('sha256').update(salt + secretKey).digest('hex');
}

module.exports = {
  generateId,
  generateApiKey,
  hashSecretKey
};

================
File: src/utils/logger.js
================
'use strict';

const winston = require('winston');
const config = require('../config');

/**
 * Configuración del formato de log según el entorno
 */
const formats = {
  // Formato para desarrollo: colorizado y más legible
  development: winston.format.combine(
    winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
    winston.format.colorize(),
    winston.format.printf(({ level, message, timestamp, ...meta }) => {
      let metaStr = '';
      if (Object.keys(meta).length > 0) {
        // Mostrar metadatos en formato más simple sin profundidad excesiva
        metaStr = JSON.stringify(meta, null, 0).replace(/[{}"']/g, '').replace(/,/g, ', ');
        metaStr = metaStr ? ` - ${metaStr}` : '';
      }
      return `[${timestamp}] ${level}: ${message}${metaStr}`;
    })
  ),
  
  // Formato para producción: JSON estructurado para mejor análisis
  production: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  
  // Formato para tests: minimal
  test: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  )
};

/**
 * Crear el logger con la configuración adecuada según entorno
 */
const logger = winston.createLogger({
  level: config.logLevel || 'info',
  format: formats[config.nodeEnv] || formats.development,
  defaultMeta: { service: 'langfuse-admin-api' },
  transports: [
    // En test no hacemos log a consola a menos que sea error
    ...(config.isTest
      ? [
          new winston.transports.Console({
            level: 'error'
          })
        ]
      : [
          new winston.transports.Console()
        ]),
    
    // En producción agregamos log a archivo de errores
    ...(config.isProduction
      ? [
          new winston.transports.File({
            filename: 'logs/error.log',
            level: 'error',
            maxsize: 5242880, // 5MB
            maxFiles: 5,
          }),
          new winston.transports.File({
            filename: 'logs/combined.log',
            maxsize: 5242880, // 5MB
            maxFiles: 5,
          })
        ]
      : [])
  ],
  
  // No detener la aplicación si hay error de log
  exitOnError: false
});

/**
 * Utilidades para logging contextual
 */
const createContextLogger = (context) => {
  return {
    debug: (message, meta = {}) => logger.debug(message, { ...meta, context }),
    info: (message, meta = {}) => logger.info(message, { ...meta, context }),
    warn: (message, meta = {}) => logger.warn(message, { ...meta, context }),
    error: (message, meta = {}) => logger.error(message, { ...meta, context }),
  };
};

module.exports = {
  logger,
  createContextLogger
};

================
File: src/app.js
================
'use strict';

const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const compression = require('compression');
const rateLimit = require('express-rate-limit');
const swaggerUi = require('swagger-ui-express');
const YAML = require('yamljs');
const path = require('path');
const { errorHandler } = require('./middleware/error.middleware');
const { requestLogger } = require('./middleware/request.middleware');
const routes = require('./routes');
const config = require('./config');
const { logger } = require('./utils/logger');
const ConfigChecker = require('./utils/config-checker');
const { db } = require('./services/database.service');

// Crear instancia de Express
const app = express();

// Validate configuration
ConfigChecker.validateAppConfig(config);

// Middlewares de seguridad y optimización
app.use(helmet()); // Seguridad mediante cabeceras HTTP
app.use(compression()); // Compresión gzip
app.use(cors({
  origin: process.env.CORS_ORIGIN || '*',
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-API-Key'],
}));

// Rate limiting para prevenir abusos
if (process.env.NODE_ENV === 'production') {
  app.use(rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutos
    max: 100, // Límite de 100 solicitudes
    standardHeaders: true,
    legacyHeaders: false,
    message: { error: 'Demasiadas solicitudes, por favor intente más tarde' }
  }));
}

// Middlewares para parsing
app.use(express.json({ limit: '1mb' }));
app.use(express.urlencoded({ extended: true, limit: '1mb' }));

// Logging de solicitudes
app.use(requestLogger);

// Documentación API con Swagger
if (process.env.NODE_ENV !== 'production' || process.env.ENABLE_DOCS === 'true') {
  const swaggerDocument = YAML.load(path.join(__dirname, '../docs/openapi.yaml'));
  app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerDocument));
}

// Test endpoint for basic connectivity check (without DB)
app.get('/api/ping', (req, res) => {
  res.json({ 
    status: 'ok',
    timestamp: new Date(),
    message: 'API server is running'
  });
});

// Rutas API
app.use('/api', routes);

// Página de documentación básica
app.get('/', (req, res) => {
  res.redirect('/api-docs');
});

// Error 404 para rutas no definidas
app.use((req, res) => {
  res.status(404).json({ error: 'Ruta no encontrada' });
});

// Manejador de errores global
app.use(errorHandler);

// Initialize the application
const initApp = async () => {
  try {
    // Check database connection at startup
    const dbStatus = await db.checkConnection();
    if (dbStatus.status === 'connected') {
      logger.info('Database connection successful on startup');
    } else {
      logger.warn('Database connection check failed on startup', {
        error: dbStatus.error,
        code: dbStatus.code
      });
      
      // We don't fail startup if DB connection fails - the app can still serve API documentation
      // and other endpoints that don't require DB access, like /api/ping
    }
  } catch (error) {
    logger.error('Error during application initialization', {
      error: error.message,
      stack: error.stack
    });
  }
};

// Execute initialization
initApp().catch(err => {
  logger.error('Unexpected error during initialization', err);
});

module.exports = app;

================
File: .dockerignore
================
# Dependencias y módulos de node
node_modules
npm-debug.log
yarn-debug.log
yarn-error.log

# Tests
coverage
.nyc_output
tests

# Archivos de desarrollo
.git
.github
.gitignore
.editorconfig
.eslintrc.js
.eslintignore
.prettierrc
.prettierignore
*.md
!README.md

# Variables de entorno y configuración local
.env
.env.*
!.env.example

# Logs
logs
*.log

# Directorios y archivos específicos del IDE/editor
.idea
.vscode
*.sublime-project
*.sublime-workspace
*.swp
*.swo

# Sistema operativo
.DS_Store
Thumbs.db

================
File: .eslintrc.js
================
module.exports = {
    env: {
      node: true,
      commonjs: true,
      es2021: true,
      jest: true,
    },
    extends: [
      'eslint:recommended',
      'plugin:node/recommended',
      'plugin:jest/recommended',
      'prettier',
    ],
    plugins: ['jest', 'prettier'],
    parserOptions: {
      ecmaVersion: 2022,
    },
    rules: {
      'prettier/prettier': 'error',
      'no-console': 'warn',
      'no-unused-vars': ['error', { argsIgnorePattern: '^_' }],
      'node/no-unsupported-features/es-syntax': [
        'error',
        { ignores: ['modules'] },
      ],
      'jest/expect-expect': 'warn',
      'node/no-unpublished-require': [
        'error', 
        { allowModules: ['supertest'] }
      ],
      'node/no-missing-require': 'error',
      'node/no-extraneous-require': 'error',
      'node/no-deprecated-api': 'warn',
      'strict': ['error', 'global'],
    },
    overrides: [
      {
        files: ['tests/**/*.js', '**/*.test.js'],
        rules: {
          'node/no-unpublished-require': 'off',
        },
      },
    ],
  };

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# vitepress build output
**/.vitepress/dist

# vitepress cache directory
**/.vitepress/cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

================
File: Dockerfile
================
# Imagen base con Node.js
FROM node:18-alpine AS base

# Crear directorio de la aplicación
WORKDIR /app

# Instalación de dependencias
FROM base AS deps
COPY package*.json ./
RUN npm ci --omit=dev

# Compilación (si se necesitara)
FROM base AS builder
COPY --from=deps /app/node_modules ./node_modules
COPY . .

# Producción
FROM base AS runner
ENV NODE_ENV production

# Crear usuario para ejecutar la app (no usar root)
RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 langfuse
USER langfuse

# Copiar los archivos de la aplicación
COPY --from=builder --chown=langfuse:nodejs /app/package.json ./package.json
COPY --from=builder --chown=langfuse:nodejs /app/index.js ./index.js
COPY --from=builder --chown=langfuse:nodejs /app/docs ./docs
COPY --from=builder --chown=langfuse:nodejs /app/src ./src
COPY --from=deps --chown=langfuse:nodejs /app/node_modules ./node_modules

# Crear directorio para logs (asegurando permisos)
RUN mkdir -p logs && chown -R langfuse:nodejs logs

# Puerto de la aplicación
EXPOSE 3100

# Health check
HEALTHCHECK --interval=30s --timeout=5s --start-period=5s --retries=3 \
  CMD wget -qO- http://localhost:3100/api/health || exit 1

# Comando para iniciar la aplicación
CMD ["node", "index.js"]

================
File: index.js
================
#!/usr/bin/env node
'use strict';

// Carga de variables de entorno antes de cualquier importación
require('dotenv').config();

// Importar módulos
const app = require('./src/app');
const config = require('./src/config');
const { logger } = require('./src/utils/logger');
const { db } = require('./src/services/database.service');

// Logging de variables de entorno (excluyendo datos sensibles)
logger.info('Starting application with configuration', {
  NODE_ENV: process.env.NODE_ENV || 'development',
  PORT: process.env.PORT || 3100,
  DB_HOST: process.env.DB_HOST || 'localhost',
  DB_PORT: process.env.DB_PORT || 5432,
  DB_NAME: process.env.DB_NAME || 'postgres',
  DB_USER: process.env.DB_USER || 'postgres',
  DB_SSL: process.env.DB_SSL || false,
  CORS_ORIGIN: process.env.CORS_ORIGIN || '*',
  ENABLE_API_KEY_AUTH: process.env.ENABLE_API_KEY_AUTH || true,
  ENABLE_DOCS: process.env.ENABLE_DOCS || true,
});

// Gestión de errores no capturados
process.on('uncaughtException', (error) => {
  logger.error('Error no capturado:', error);
  // En producción, podríamos querer reiniciar el proceso con PM2 o similar
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  logger.error('Promesa rechazada no manejada:', reason);
  // No cerramos el proceso aquí, solo registramos
});

// Función para iniciar el servidor
async function startServer() {
  try {
    // Iniciar el servidor
    const server = app.listen(config.port, () => {
      logger.info(`
🚀 Langfuse Admin API ejecutándose en puerto ${config.port}

📝 Documentación: http://localhost:${config.port}/api-docs
🔍 Estado: http://localhost:${config.port}/api/health
🔍 Ping (sin BD): http://localhost:${config.port}/api/ping

Esta API está diseñada para uso administrativo y ofrece autenticación mediante API keys.
      `);
    });

    // Gestión de señales del sistema operativo
    const shutdown = async (signal) => {
      logger.info(`${signal} recibido. Cerrando servidor HTTP y conexiones a base de datos...`);
      
      // Intentar cerrar la conexión de BD primero
      try {
        await db.close();
        logger.info('Conexiones de base de datos cerradas correctamente.');
      } catch (err) {
        logger.warn('Error al cerrar conexiones de base de datos:', err);
      }
      
      // Luego cerrar el servidor HTTP
      server.close(() => {
        logger.info('Servidor HTTP cerrado.');
        process.exit(0);
      });

      // Timeout forzado por si no cierra correctamente
      setTimeout(() => {
        logger.error('No se pudo cerrar correctamente, forzando salida.');
        process.exit(1);
      }, 10000);
    };

    // Registro de manejadores de señal
    process.on('SIGTERM', () => shutdown('SIGTERM'));
    process.on('SIGINT', () => shutdown('SIGINT'));
  } catch (error) {
    logger.error('Error al iniciar el servidor:', error);
    process.exit(1);
  }
}

// Iniciar el servidor
startServer();

================
File: package.json
================
{
  "name": "langfuse-admin-api",
  "version": "1.0.0",
  "description": "API de administración para Langfuse",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "dev": "nodemon index.js",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "format": "prettier --write '**/*.{js,json,md}'",
    "prepare": "husky install",
    "docker:build": "docker build -t langfuse-admin-api .",
    "docker:run": "docker run -p 3100:3100 langfuse-admin-api"
  },
  "keywords": [
    "langfuse",
    "admin",
    "api",
    "node",
    "express"
  ],
  "author": "Langfuse Team",
  "license": "MIT",
  "engines": {
    "node": ">=18.0.0"
  },
  "dependencies": {
    "compression": "^1.7.4",
    "cors": "^2.8.5",
    "crypto": "^1.0.1",
    "cuid": "^2.1.8",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "express-rate-limit": "^7.1.5",
    "helmet": "^7.0.0",
    "joi": "^17.11.0",
    "morgan": "^1.10.0",
    "nanoid": "^3.3.6",
    "pg": "^8.14.0",
    "swagger-ui-express": "^5.0.0",
    "uuid": "^11.1.0",
    "winston": "^3.11.0",
    "yamljs": "^0.3.0"
  },
  "devDependencies": {
    "eslint": "^8.56.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-jest": "^27.9.0",
    "eslint-plugin-node": "^11.1.0",
    "eslint-plugin-prettier": "^5.1.3",
    "husky": "^9.0.11",
    "jest": "^29.7.0",
    "lint-staged": "^15.2.0",
    "nodemon": "^3.0.3",
    "prettier": "^3.2.5",
    "supertest": "^6.3.4"
  },
  "lint-staged": {
    "*.js": [
      "eslint --fix",
      "prettier --write"
    ],
    "*.{json,md}": [
      "prettier --write"
    ]
  },
  "jest": {
    "testEnvironment": "node",
    "coveragePathIgnorePatterns": [
      "/node_modules/",
      "/tests/"
    ]
  }
}

================
File: README.md
================
# Langfuse Admin API

API de administración para [Langfuse](https://langfuse.com) que permite gestionar organizaciones, proyectos y API keys.

## 🚀 Características

- ✅ Gestión completa de organizaciones y miembros
- ✅ Administración de proyectos
- ✅ Creación y gestión de API keys
- ✅ Autenticación simple mediante API key
- ✅ Documentación OpenAPI/Swagger
- ✅ Arquitectura modular y robusta

## 📋 Requisitos

- Node.js >= 18
- PostgreSQL >= 14

## 🛠️ Instalación

1. Clonar el repositorio

```bash
git clone https://github.com/tu-usuario/langfuse-admin-api.git
cd langfuse-admin-api
```

2. Instalar dependencias

```bash
npm install
```

3. Configurar variables de entorno

```bash
cp .env.example .env
# Editar .env con los valores apropiados
```

4. Iniciar el servidor

```bash
npm start
```

Para desarrollo:

```bash
npm run dev
```

## 📊 Estructura del Proyecto

```
src/
 ├── config/         # Configuración centralizada
 ├── controllers/    # Controladores de rutas
 ├── middleware/     # Middleware Express
 ├── models/         # Modelos de datos
 ├── routes/         # Definición de rutas
 ├── services/       # Lógica de negocio
 ├── utils/          # Utilidades
 └── app.js          # Punto de entrada Express
```

## 📚 Endpoints API

La documentación completa está disponible en `/api-docs` cuando el servidor está en ejecución.

### Organizaciones

- `GET /api/organizations` - Listar organizaciones
- `GET /api/organizations/:id` - Obtener organización por ID
- `POST /api/organizations` - Crear una organización
- `PUT /api/organizations/:id` - Actualizar una organización

### Miembros de Organización

- `GET /api/organizations/:id/members` - Listar miembros
- `POST /api/organizations/:id/members` - Añadir miembro
- `PUT /api/organizations/:orgId/members/:userId` - Actualizar rol
- `DELETE /api/organizations/:orgId/members/:userId` - Eliminar miembro

### Proyectos

- `GET /api/projects` - Listar proyectos
- `GET /api/projects/:id` - Obtener proyecto por ID
- `POST /api/projects` - Crear un proyecto
- `PUT /api/projects/:id` - Actualizar un proyecto
- `DELETE /api/projects/:id` - Eliminar un proyecto

### API Keys

- `GET /api/projects/:id/api-keys` - Listar API keys
- `POST /api/projects/:id/api-keys` - Crear API key
- `DELETE /api/api-keys/:id` - Eliminar API key

## 🧪 Tests

Ejecutar los tests:

```bash
npm test
```

Con cobertura:

```bash
npm run test:coverage
```

## 🔧 Desarrollo

Verificar código:

```bash
npm run lint
```

Formatear código:

```bash
npm run format
```

## 🐳 Docker

Construir imagen:

```bash
npm run docker:build
```

Ejecutar contenedor:

```bash
npm run docker:run
```

## 📃 Licencia

[MIT](LICENSE)



================================================================
End of Codebase
================================================================
